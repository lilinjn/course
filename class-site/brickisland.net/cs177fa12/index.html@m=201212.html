<!DOCTYPE html>
<html dir="ltr" lang="en-US">
<head>
    <meta charset="UTF-8" />
    <title>December &raquo; 2012 &raquo;  CS 177: Discrete Differential Geometry</title>
    <!--[if lt IE 9]>
    <script type="text/javascript" src="http://brickisland.net/cs177fa12/wp-content/themes/constructor/js/html5.js"></script>
    <![endif]-->
    <link rel="profile" href="http://gmpg.org/xfn/11" />
    <link rel="stylesheet" type="text/css" media="screen" href="wp-content/themes/constructor/style.css"/>
    <link rel="stylesheet" type="text/css" media="print" href="wp-content/themes/constructor/print.css" />
	<link rel="stylesheet" type="text/css" media="only screen and (max-device-width: 480px)" href="wp-content/themes/constructor/style-480.css" />
    <link rel="pingback" href="xmlrpc.php" />
    	<link rel='archives' title='December 2012' href='index.html@m=201212.html' />
	<link rel='archives' title='November 2012' href='index.html@m=201211.html' />
	<link rel='archives' title='October 2012' href='index.html@m=201210.html' />
    
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<link rel="alternate" type="application/rss+xml" title="CS 177: Discrete Differential Geometry &raquo; Feed" href="index.html@feed=rss2" />
<link rel="alternate" type="application/rss+xml" title="CS 177: Discrete Differential Geometry &raquo; Comments Feed" href="index.html@feed=comments-rss2" />
<link rel='stylesheet' id='constructor-style-css'  href='wp-content/uploads/constructor/cache/style.css' type='text/css' media='all' />
<link rel='stylesheet' id='constructor-theme-css'  href='wp-content/uploads/constructor/themes/current/style.css' type='text/css' media='all' />
<script type='text/javascript' src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#038;ver=3.4.2'></script>
<script type='text/javascript' src='wp-includes/js/jquery/jquery.js@ver=1.7.2'></script>
<script type='text/javascript' src='wp-content/themes/constructor/js/ready.js'></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="xmlrpc.php@rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 3.4.2" />
	<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
</head>
<body class="archive date">
	
<div id="body">
   <div id="wrapheader" class="wrapper">
       <header id="header">
                        <div id="title">
					
					<div id="name"><a href="index.html" title="CS 177: Discrete Differential Geometry &raquo; Caltech | Fall 2012 | Tue/Thu 10:30-11:55 | 314 ANB">CS 177: Discrete Differential Geometry</a></div>
				                <div id="description">Caltech | Fall 2012 | Tue/Thu 10:30-11:55 | 314 ANB</div>
            </div>
       </header>
   </div>
   
   <div id="wrapcontent" class="wrapper">
       <div id="content" class="box shadow opacity layout-right">
    <div id="container" >
                            <article class="post-320 post type-post status-publish format-standard hentry category-homework" id="post-320">
                <header class="opacity box">
                    <h2><a href="index.html@p=320.html" rel="bookmark" title="Permanent Link to Homework 4: Curvature Flow">Homework 4: Curvature Flow</a></h2>
                </header>
                <div class="entry">
                	<p><a href="wp-content/uploads/2012/12/ddg_curvature_flow.svg"><img class="aligncenter size-full wp-image-331" title="ddg_curvature_flow" src="wp-content/uploads/2012/12/ddg_curvature_flow.svg" alt="" /></a></p>
<p>In this homework we&#8217;ll take a closer look at <em>curvature flow</em>. We already saw one example of curvature flow (<em>mean</em> curvature flow) while studying the Poisson equation. The general idea behind curvature flow is that we have an <em>energy</em> \(E\) measuring the smoothness of our geometry, and can reduce this energy by traveling along the direction of steepest descent. Conceptually, you can imagine that \(E\) is some kind of potential &#8212; surfaces with many wrinkles have a lot of energy, and want to reduce this energy by &#8220;relaxing&#8221; into a smoother state. This description suggests a sort of &#8220;energy landscape,&#8221; where high peaks correspond to wrinkly surfaces and low valleys correspond to smooth ones. Here&#8217;s a two-dimensional cartoon of what this landscape might look like:</p>
<p><a href="wp-content/uploads/2012/12/ddg_energy_landscape.svg"><img class="aligncenter size-full wp-image-332" title="ddg_energy_landscape" src="wp-content/uploads/2012/12/ddg_energy_landscape.svg" alt="" /></a></p>
<p>To smooth out the geometry we can &#8220;ski&#8221; downhill, discovering a sequence of smoother and smoother surfaces along the way. Visually the effect is akin to a pat of butter slowly melting away on a hot piece of toast, or a water droplet buckling into a perfectly round sphere.</p>
<p>To be more concrete, let \(f\) be an immersion of a manifold \(M\) (e.g., a curve or surface) into Euclidean space, and suppose that \(E\) is a real-valued function of \(f\). Then a curvature flow is the solution to the partial differential equation<br />
\[ \dot{f} = -\nabla E(f) \]<br />
starting with some initial immersion \(f_0\), where \(\dot{f}\) denotes the derivative in time. In words, this equation just says that the difference in position of the surface at two consecutive points in time is equal to the change in position that reduces the energy quickest.</p>
<p>For surfaces, two common energies are the <em>Dirichlet energy</em><br />
\[ E_D(f) = \frac{1}{4} \int_M |\nabla f|^2 dA \]<br />
and the <em>Willmore energy</em><br />
\[ E_W(f) = \frac{1}{4} \int_M (\kappa_1 - \kappa_2)^2 dA. \]<br />
where as usual \(\kappa_1\) and \(\kappa_2\) are the principal curvatures induced by \(f\). Both energies somehow measure the &#8220;wrinkliness&#8221; of a surface, but how are they related?</p>
<hr />
<p><strong>Exercise 4.1</strong><br />
For a surface \(M\) without boundary show that, up to an additive constant, the Willmore energy can be expressed as<br />
\[ E_W = \int_M H^2\ dA \]<br />
and explain why this constant does not matter in the context of curvature flow. <em>Hint: Gauss-Bonnet.</em></p>
<hr />
<p>In other words, Dirichlet energy looks like the (squared) \(L^2\) norm of the gradient, whereas Willmore energy looks like the (squared) \(L^2\) norm of mean curvature. Superficially these quantities look quite different, but in fact they are quite similar!</p>
<hr />
<p><strong>Exercise 4.2</strong><br />
For a surface \(M\) without boundary show that (again up to constant factors)<br />
\[ E_D = \langle \Delta f, f \rangle, \]<br />
\[ E_W = \langle \Delta^2 f, f \rangle, \]<br />
<em>Hint: Green&#8217;s first identity and the definition of the mean curvature normal.</em></p>
<hr />
<p>From these expressions, it may appear that Dirichlet and Willmore energy are nice, simple, quadratic functions of \(f\). Don&#8217;t be fooled! The Laplace-Beltrami operator \(\Delta\) depends on the immersion \(f\) itself, which means that the corresponding gradient flows are rather nasty and nonlinear. Later on we&#8217;ll look at a couple ways to deal with this nonlinearity.</p>
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">Gradient Descent</span></strong></p>
<p>Now that have a couple energies to work with, how do we derive gradient flow? Previously we defined the gradient of a function \(\phi: \mathbb{R}^n \rightarrow \mathbb{R}\) as<br />
\[ \nabla\phi = \left[ \begin{array}{c} \partial\phi/\partial x^1 \\ \vdots \\ \partial\phi/\partial x^n \end{array} \right], \]<br />
i.e., as just a list of all the partial derivatives. This definition works pretty well when \(\phi\) is defined over a nice finite-dimensional vector space like \(\mathbb{R}^n\), but what about something more exotic like the Willmore energy, which operates on an infinite-dimensional vector space of functions? In general, the gradient of a function \(\phi\) at a point \(x\) can be defined as the unique vector \(\nabla \phi(x)\) satisfying<br />
\[ \langle \nabla \phi(x), u \rangle = \lim_{h \rightarrow 0} \frac{\phi(x+hu)-\phi(x)}{h}, \]<br />
for all vectors \(u\), where \(\langle \cdot, \cdot \rangle\) denotes the inner product on the vector space. In other words, taking the inner product with the gradient should yield the directional derivative in the specified direction. Notice that this definition actually serves as a <em>definition</em> of differentiability: a function is differentiable at \(x\) if and only if all directional derivatives can be characterized by a single vector \(\nabla\phi(x)\). Geometrically, then, differentiability means that if we &#8220;zoom in&#8221; far enough the function looks almost completely flat.</p>
<hr />
<p><strong>Exercise 4.3</strong><br />
Explain why the gradient is the direction of steepest ascent.</p>
<hr />
<hr />
<p><strong>Exercise 4.4</strong><br />
Consider the function<br />
\[ \phi: \mathbb{R}^2 \rightarrow \mathbb{R}; (x_1, x_2) \mapsto x_1^2 - x_2^2. \]<br />
Confirm that the gradient found using the expression above agrees with the usual gradient found via partial derivatives.</p>
<hr />
<hr />
<p><strong>Exercise 4.5</strong><br />
Let \(M\) be a surface without boundary. Assume that the Laplace-Beltrami operator \(\Delta\) is constant with respect to the immersion \(f\) and use our definition of \(\nabla\) above to show that<br />
\[ \nabla E_D(f) \approx HN. \]<br />
In other words, gradient flow on Dirichlet energy looks roughly like the mean curvature flow \(\dot{f} = -HN\) that we studied in the previous assignment.</p>
<hr />
<p>The approximate gradient \(HN\) might be called a <em>linearization</em> of the true gradient &#8212; in general the idea is that we keep some quantity or some piece of an equation fixed so that the rest comes out to be a nice linear expression. This trick can be quite helpful in a practical setting, but it is typically worth understanding where and how the approximation affects the final result.</p>
<p>One final thing to mull over is the fact that the gradient depends on our particular choice of inner product \(\langle \cdot, \cdot \rangle\), which appears on the left-hand side in our definition. Why does the inner product matter? Intuitively, the gradient picks out the direction in which the energy increases fastest. But what does &#8220;fastest&#8221; mean? For instance, if we use a vector of real numbers \(\mathsf{x} \in \mathbb{R}^m\) to encode the vertices of a discrete curve, then what we really care about is the energy increase with respect to a change in the length of the <em>curve</em> &#8212; not the Euclidean length of the vector \(\mathsf{x}\) itself. In terms of our energy landscape we end up with a picture like the one below &#8212; you can imagine, for instance, that arrows on the left have unit norm with respect to the standard Euclidean inner product whereas arrows on the right have unit norm with respect to the \(L^2\) inner product on our discrete curve. As a result, gradient descent will proceed along two different trajectories:</p>
<p><a href="wp-content/uploads/2012/12/ddg_gradient_metric.svg"><img class="aligncenter size-full wp-image-333" title="ddg_gradient_metric" src="wp-content/uploads/2012/12/ddg_gradient_metric.svg" alt="" /></a></p>
<hr />
<p><strong>Exercise 4.6</strong><br />
Consider an inner product \(\langle \cdot, \cdot \rangle\) on \(\mathbb{R}^n\) defined by a positive definite matrix \(\mathsf{B} \in \mathbb{R}^{n \times n}\), i.e., \(\langle u, v \rangle = \mathsf{u^T B v}\). Show that the gradient \(\nabla_B\) induced by this inner product is related to the standard gradient \(\nabla\) via<br />
\[ \nabla_\mathsf{B} = \mathsf{B}^{-1} \nabla. \]</p>
<hr />
<p>In the discrete setting, the matrix \(\mathsf{B}\) is sometimes referred to as the <em>mass matrix</em>, because it encodes the amount of &#8220;mass&#8221; each degree of freedom contributes to the total. When working with discrete differential forms, one possible choice mass matrix is given by (an appropriate constant multiple of) the diagonal Hodge star. This choice corresponds to applying piecewise-constant interpolation and then taking the usual \(L^2\) inner product. For instance, here&#8217;s what piecewise constant interpolation looks like for a primal 1-form on a triangulated surface &#8212; the integrated value stored on a given edge gets &#8220;spread out&#8221; over the so-called <em>diamond region</em> associated with that edge:</p>
<p><a href="wp-content/uploads/2012/12/ddg_piecewise_constant_interpolation.svg"><img class="aligncenter size-full wp-image-334" title="ddg_piecewise_constant_interpolation" src="wp-content/uploads/2012/12/ddg_piecewise_constant_interpolation.svg" alt="" /></a></p>
<p>In general, let \(\star_k\) be a real diagonal matrix with one entry for each \(k\)-dimensional simplex \(\sigma_i\). The nonzero entries are<br />
\[ \left( \star_k \right)_{ii} = \frac{|\sigma_i^\star|}{|\sigma_i|}, \]<br />
where \(\sigma_i^\star\) is the circumcentric dual of \(\sigma\), and \(|\cdot|\) denotes the (unsigned) volume. The corresponding mass matrix on primal discrete \(k\)-forms in \(n\) dimensions is then<br />
\[ B_k = \left( \begin{array}{c} n \\ k \end{array} \right) \star_k, \]<br />
i.e., a binomial coefficient times a (primal) diagonal Hodge star. The mass matrices for <em>dual</em> \(k\)-forms can likewise be expressed as constant multiples of the inverse:<br />
\[ B^\star_k = \left( \begin{array}{c} n \\ k \end{array} \right) \star_{n-k}^{-1}. \]<br />
These matrices will come in handy when deriving equations for discrete curvature flow.</p>
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">Flow on Curves</span></strong></p>
<p><a href="wp-content/uploads/2012/12/ddg_curve_energy.svg"><img class="aligncenter size-full wp-image-335" title="ddg_curve_energy" src="wp-content/uploads/2012/12/ddg_curve_energy.svg" alt="" /></a></p>
<p>For the remainder of this assignment, we&#8217;re going to make life simpler by working with planar curves instead of surfaces. As discussed earlier, we can describe the geometry of a curve via an immersion<br />
\[ \gamma: I \rightarrow \mathbb{R}^2; s \mapsto \gamma(s)\]<br />
of some interval \(I = [0,L] \subset \mathbb{R}\) into the Euclidean plane \(\mathbb{R}^2\). A common energy for curves is simply the integral of the curvature \(\kappa\), squared:<br />
\[ E(\gamma) = \int_0^L \kappa^2\ ds. \]<br />
Let&#8217;s first establish some facts about curvature in the smooth setting.</p>
<hr />
<p><strong>Exercise 4.7</strong><br />
The unit tangent field on a smooth curve \(\gamma\) can be expressed as \(T = (\cos\theta,\sin\theta)\) for some function \(\theta: I \rightarrow \mathbb{R}\). Show that the normal curvature can be expressed as<br />
\[ \kappa = d\theta(X) \]<br />
where \(X\) is a positively-oriented unit vector field. In other words, the scalar curvature is change in the direction of the tangent.</p>
<hr />
<hr />
<p><strong>Exercise 4.8</strong><br />
Explain in words why the total curvature of any closed immersed curve \(\gamma\) (whether discrete or not) is an integer multiple of \(2\pi\), i.e., \(\gamma(0) = \gamma(L)\)<br />
\[ \int_0^L \kappa ds = 2\pi k,\ k \in \mathbb{Z}. \]<br />
(The number \(k\) is called the <em>turning number</em> of the curve.)</p>
<hr />
<p>A stronger statement is the <em>Whitney-Graustein theorem</em> which says that the turning number of a curve will be preserved by any <em>regular homotopy</em>, i.e., by any continuous motion that keeps the curve immersed. For instance, here&#8217;s an example of a motion that is <em>not</em> a regular homotopy &#8212; note that the curve gets &#8220;pinched&#8221; into a sharp cusp halfway thorugh the motion, at which point the turning number goes from \(k=2\) to \(k=1\):</p>
<p><a href="wp-content/uploads/2012/12/ddg_irregular_homotopy.svg"><img class="aligncenter size-full wp-image-336" title="ddg_irregular_homotopy" src="wp-content/uploads/2012/12/ddg_irregular_homotopy.svg" alt="" /></a></p>
<p>We&#8217;ll keep these ideas in mind as we develop algorithms for curvature flow.</p>
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">Discrete Curves</span></strong></p>
<p>In the discrete setting, \(\gamma\) is simply a collection of line segments connecting a sequence of vertices with coordinates \( \gamma_1, \ldots, \gamma_n \in \mathbb{R}^2 \):</p>
<p><a href="wp-content/uploads/2012/12/ddg_discrete_curve.svg"><img class="aligncenter size-full wp-image-337" title="ddg_discrete_curve" src="wp-content/uploads/2012/12/ddg_discrete_curve.svg" alt="" /></a></p>
<p>Note that in the provided code framework, a curve is represented by a half edge mesh consisting of a single polygon. Therefore, to iterate over the curve you might write something like</p>
<p><code>
<pre>   FaceIter gamma = mesh.faces.begin();
    HalfEdgeIter he = gamma->he;
    do {
       // do something interesting here!
       he = he->next;
    }
    while( he != gamma->he );
</pre>
<p></code></p>
<p>As with surfaces, we can consider both a primal and dual &#8220;mesh&#8221; associated with this curve &#8212; this time, each primal edge is associated with a dual vertex at its midpoint, and each primal vertex is associated with a dual edge connecting the two adjacent dual vertices:</p>
<p><a href="wp-content/uploads/2012/12/ddg_simplicial_dual_1d.svg"><img class="aligncenter size-full wp-image-338" title="ddg_simplicial_dual_1d" src="wp-content/uploads/2012/12/ddg_simplicial_dual_1d.svg" alt="" /></a></p>
<p>In the language of discrete exterior calculus, then, \(\gamma \in (\mathbb{R}^2)^n\) is a \(\mathbb{R}^2\)-valued primal 0-form, i.e., a value associated with each vertex.</p>
<hr />
<p><strong>Exercise 4.9</strong><br />
Show that the nonzero entries of the diagonal Hodge star on primal 0-forms are given by<br />
\[ (\star_0)_{ii} = L_i, \]<br />
where<br />
\[ L_i = \frac{1}{2}( |\gamma_{i+1}-\gamma_i| + |\gamma_i-\gamma_{i-1}| ). \]</p>
<hr />
<hr />
<p><strong>Coding 4.1</strong><br />
Implement the methods <tt>Edge::length()</tt> and <tt>Vertex::dualLength()</tt>, which should return the primal edge length and the circumcentric dual edge length, respectively. (The latter should be a one-liner that just calls the former!) Finally, implement the method <tt>IsometricWillmoreFlow1D::buildMassMatrix()</tt>, which builds the diagonal Hodge star on primal 0-forms.</p>
<hr />
<hr />
<p><strong>Exercise 4.10</strong><br />
Show that on a discrete curve the total curvature along a dual edge \(e^\star_{ij}\) is equal to the exterior angle \(\varphi_{ij} \in \mathbb{R}\) at the corresponding vertex, i.e., the difference in angle between the two consecutive tangents:<br />
\[ \varphi_{ij} = \theta_j - \theta_i = \int_{e^\star_{ij}} \kappa\ ds. \]<br />
<em>(Hint: Stokes&#8217; theorem!)</em></p>
<hr />
<p>In other words, the exterior angle \(\varphi\) gives us the <em>integrated</em> curvature. Applying the discrete Hodge star yields <em>pointwise</em> curvatures \(\kappa\), which we will use as the degrees of freedom in our numerical curvature flow:<br />
\[ \kappa = \star\varphi. \]</p>
<hr />
<p><strong>Coding 4.2</strong><br />
Implement the method <tt>Vertex::curvature()</tt>, which returns the pointwise curvature as defined above. <em>Hint: in the language of discrete exterior calculus, what kind of quantity is \(\varphi\)? And what kind of quantity is \(\kappa\)?</em></p>
<hr />
<p>The next exercise should solidify your understanding of where all these different quantities live, and which operators take you back and forth from one space to another!</p>
<hr />
<p><strong>Exercise 4.11</strong><br />
Show that for a discrete curve \(E(\gamma)\) can be written explicitly as<br />
\[ E(\gamma) = \sum_i \varphi_i^2 / L_i, \]<br />
assuming we use piecewise constant interpolation of curvature.</p>
<hr />
<p>Now that we have a discrete curvature energy, let&#8217;s derive an expression for the gradient.</p>
<hr />
<p><strong>Exercise 4.12</strong></p>
<p>Let \(\varphi\) be the angle made by two vectors \(u,v \in \mathbb{R}^2\). Show that the gradient of \(\varphi\) with respect to \(u\) can be expressed as<br />
\[ \nabla_u \varphi = -\frac{v_{\perp u}}{2A} \]</p>
<p><a href="wp-content/uploads/2012/12/ddg_angle_gradient.svg"><img class="aligncenter size-full wp-image-339" title="ddg_angle_gradient" src="wp-content/uploads/2012/12/ddg_angle_gradient.svg" alt="" /></a></p>
<p>where \(v_{\perp u}\) denotes the component of \(v\) orthogonal to \(u\) and \(A\) is the area of a triangle with sides \(u\) and \(v\).</p>
<hr />
<hr />
<p><strong>Exercise 4.13</strong><br />
Let \(L\) be the length of a vector \(u = b-a\), where \(a\) and \(b\) are a pair of points in \(\mathbb{R}^2\). Show that<br />
\[ \nabla_a L = -\hat{u} \]<br />
and<br />
\[ \nabla_b L = \hat{u}. \]</p>
<p><a href="wp-content/uploads/2012/12/ddg_length_gradient.svg"><img class="aligncenter size-full wp-image-340" title="ddg_length_gradient" src="wp-content/uploads/2012/12/ddg_length_gradient.svg" alt="" /></a></p>
<hr />
<hr />
<p><strong>Exercise 4.14</strong><br />
Collecting the results of the past few exercises, show that the gradient of the \(i\)th term of our curvature energy<br />
\[ E_i = \varphi_i^2 / L_i \]<br />
with respect to vertex coordinates \(\gamma_{i-1}\), \(\gamma_i\), and \(\gamma_{i+1}\) is given explicitly by<br />
\[<br />
\begin{array}{rcr}<br />
\nabla_{\gamma_{i-1}} E_i &amp;=&amp; \frac{\varphi_i}{L_i L_{i-1}} \left( \frac{v_{\perp u}}{A_i} + \frac{\varphi_i}{2L_i} \hat{u} \right) \\<br />
\nabla_{\gamma_{i+1}} E_i &amp;=&amp; \frac{\varphi_i}{L_i^2} \left( \frac{u_{\perp v}-v_{\perp u}}{A_i} + \frac{\varphi_i}{2L_i} (\hat{v}-\hat{u}) \right) \\<br />
\nabla_{\gamma_i} E_i &amp;=&amp; -\frac{\varphi_i}{L_i L_{i+1}} \left( \frac{u_{\perp v}}{A_i} + \frac{\varphi_i}{2L_i} \hat{v} \right) \\<br />
\end{array}<br />
\]</p>
<p><a href="wp-content/uploads/2012/12/ddg_exterior_angle_gradient.svg"><img class="aligncenter size-full wp-image-341" title="ddg_exterior_angle_gradient" src="wp-content/uploads/2012/12/ddg_exterior_angle_gradient.svg" alt="" /></a></p>
<p>where \(\varphi_i\) is the exterior angle at vertex \(i\), \(L_i\) is the dual edge length, and \(A_i\) is the area of a triangle with edges \(u = \gamma_i-\gamma_{i-1}\) and \(v = \gamma_{i+1}-\gamma_i\). The gradient of \(E_i\) with respect to all other vertices \(\gamma_j\) is zero. Why? <em>(Hint: remember to take the gradient with respect to the right metric!)</em></p>
<hr />
<hr />
<p><strong>Coding 4.3</strong><br />
Implement the method <tt>WillmoreFlow1D::computeGradient()</tt> using the expressions above. The gradient of energy with respect to a given vertex should be stored in the member <tt>Vertex::energyGradient</tt>. Remember that the overall energy is a <em>sum</em> over the terms \(E_i\), which means you will need to add up the contributions to the gradient at each vertex.</p>
<hr />
<hr />
<p><strong>Coding 4.4</strong><br />
Implement the method <tt>WillmoreFlow1D::integrate()</tt>, which should integrate the flow equation<br />
\[ \dot{\gamma} = -\nabla E(\gamma) \]<br />
using the forward Euler scheme. (See the end of the previous assignment for a brief discussion of time integration.) Run the code on the provided meshes, and report the maximum stable time step in each case, i.e., the largest time step for which the flow succeeds at smoothing out the curve. (The time step size can be adjusted using the keys &#8216;<tt>-</tt>&#8216;, &#8216;<tt>=</tt>&#8216;, &#8216;<tt>\_</tt>&#8216;, and &#8216;<tt>+</tt>.&#8217;)</p>
<hr />
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">Curvature Flow in Curvature Space</span></strong></p>
<p>If you feel exhausted at this point in the assignment, you&#8217;re not alone! Taking derivatives by hand can be a royal pain (and it gets even worse when you want second derivatives, which are required for more sophisticated algorithms like Newton descent). But it&#8217;s worth grinding out this kind of expression at least once in your life so that you really understand what&#8217;s involved. In practice there are a variety of alternatives, including <a href="http://en.wikipedia.org/wiki/Numerical_differentiation">numerical differentiation</a>, <a href="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>, and <a href="http://en.wikipedia.org/wiki/Symbolic_differentiation">symbolic differentiation</a> &#8212; these methods all have their place, and it&#8217;s well-worth understanding the tradeoffs they offer in terms of accuracy, efficiency, and code complexity.</p>
<p>But before getting mired in the bedraggled business of computer-based derivatives, it&#8217;s worth realizing that there is a tantalizing fourth alternative: come up with a simpler formulation of your problem! In particular, the mention of a <em>convex-quadratic energy</em> should make your mouth water and your heart beat faster, since these things make your life easier in a number of ways. &#8220;Convex-quadratic&#8221; means that your energy can be expressed as a real-valued homogeneous quadratic polynomial, i.e., as<br />
\[ E(x) = \langle Ax, x \rangle \]<br />
for some positive-semidefinite self-adjoint linear operator \(A\) that does not depend whatsoever on the argument \(x\). For instance, suppose that in the discrete setting the degrees of freedom \(x\) of our system are encoded by a vector \(\mathsf{x} \in \mathbb{R}^n\). Then a quadratic energy can always be represented as<br />
\[ E(x) = \mathsf{x^T A x} \]<br />
for some fixed symmetric positive-semidefinite matrix \(\mathsf{A} \in \mathbb{R}^{n \times n}\). Earlier we visualized definiteness in terms of the graph of the energy in two dimensions:</p>
<p><a href="wp-content/uploads/2012/12/ddg_definiteness.svg"><img class="aligncenter size-full wp-image-342" title="ddg_definiteness" src="wp-content/uploads/2012/12/ddg_definiteness.svg" alt="" /></a></p>
<p>Independent of definiteness, the gradient of a quadratic energy has a simple <em>linear</em> expression<br />
\[ \nabla E(x) = 2\mathsf{B^{-1}Ax}, \]<br />
where the matrix \(\mathsf{B} \in \mathbb{R}^{n \times n}\) encodes the inner product. This setup not only simplifies the business of taking derivatives, but also makes things inexpensive to evaluate at the numerical level &#8212; for instance, we can apply the backward Euler method by just solving a linear system, instead of performing some kind of nasty nonlinear root finding. Moreover, since the matrix \(\mathsf{A}\) is constant, we can save a lot of computation by prefactoring it once and applying backsubstitution many times. This setup also has some nice analytical features. For one thing, any local minimum of a convex energy is guaranteed to be a global minimum, which means that gradient descent will ultimately lead to an optimal solution. For another, there is an extremely well-established theory of linear PDEs, which allows one to easily answer questions about things like numerical stability. In contrast, <a href="http://mathoverflow.net/questions/15292/why-cant-there-be-a-general-theory-of-nonlinear-pde">the general theory of nonlinear PDEs is kind of a zoo</a>.</p>
<p>Ok, enough religion! Let&#8217;s see how a quadratic formulation can help us with the specific problem of curvature flow. Actually, we already have a quadratic energy &#8212; it&#8217;s<br />
\[ E(\kappa) = \int_0^L \kappa^2 ds. \]<br />
The only difference between this energy and the one we&#8217;ve been working with all along is that it&#8217;s a function of the curvature \(\kappa\) rather than the immersion \(f\) &#8212; as a result, we avoid all the nonlinearity associated with expressing \(\kappa\) in terms of \(f\). More concretely, at the discrete level we&#8217;re going to store and manipulate a single number \(\kappa_i\) at each vertex, rather than computing it indirectly from the vertex coordinates \(\gamma_i \in \mathbb{R}^2\).</p>
<hr />
<p><strong>Coding 4.5</strong><br />
Implement the method <tt>IsometricWillmoreFlow1D::getCurvature()</tt>, which simply evaluates the (pointwise) curvature at each vertex and stores it in the member <tt>Vertex::kappa</tt>. This method should call <tt>Vertex::curvature()</tt>.</p>
<hr />
<p>One nice consequence of this setup is that the gradient becomes extremely simple! Taking the gradient with respect to the \(L^2\) inner product on 0-forms, we get<br />
\[ \nabla E(\kappa) = -2\kappa. \]<br />
Gradient flow then becomes a simple, linear equation involving no spatial derivatives:<br />
\[ \dot{\kappa} = -2\kappa. \]</p>
<hr />
<p><strong>Coding 4.6</strong><br />
Implement the methods <tt>IsometricWillmoreFlow1D::computeFlowDirection()</tt> and <tt>IsometricWillmoreFlow1D::integrate()</tt>, which integrate the above flow equation using the forward Euler scheme. <em>Hint: this step should be very easy!</em></p>
<hr />
<p>If we want to actually draw the curve, we can integrate curvature to get tangents, then integrate tangents to get positions. In other words, we can recover the direction \(\theta\) of the tangent via<br />
\[ \theta(s) = \theta_0 + \int_0^s d\theta = \theta_0 + \int_0^s \kappa\ ds, \]<br />
where \(\theta_0\) specifies the direction of the first tangent on our curve. The tangent vectors themselves are given by \(T(s) = (\cos\theta(s),\sin\theta(s))\) as before. Once we have the tangents, we can recover the immersion itself via<br />
\[ f(s) = f_0 + \int_I T(s)\ ds, \]<br />
where again \(f_0\) specifies a &#8220;starting point&#8221; for the curve. In the discrete setting, these two steps correspond to a very simple reconstruction procedure: start out at some initial vertex and join the edges end to end, rotating by the exterior angles \(\varphi_i\) at each step:</p>
<p><a href="wp-content/uploads/2012/12/ddg_curve_reconstruction.svg"><img class="aligncenter size-full wp-image-343" title="ddg_curve_reconstruction" src="wp-content/uploads/2012/12/ddg_curve_reconstruction.svg" alt="" /></a></p>
<p>More explicitly, let<br />
\[ \theta_i = \sum_{k=0}^i \varphi_k \]<br />
and let<br />
\[ T_i = L_i (\cos\theta_i,\sin\theta_i), \]<br />
where \(L_i\) is the length of the \(i\)th primal edge. Then the vertex positions along the curve can be recovered via<br />
\[ \gamma_i = \sum_{k=0}^i T_k, \]<br />
mirroring the continuous formulae above. (Some questions to ponder: can you interpret these sums as piecewise integrals? What kind of quantity is \((\cos\varphi_i,\sin\varphi_i)\)? What kind of quantity is \(T_i\)? What&#8217;s the relationship between the two?)</p>
<hr />
<p><strong>Coding 4.7</strong><br />
Implement the methods <tt>IsometricWillmoreFlow1D::recoverTangents()</tt> and <tt>IsometricWillmoreFlow1D::recoverPositions()</tt>, which should compute the values \(T_i\) and \(\gamma_i\), respectively. If you use an \(O(n^2)\) algorithm to implement either of these methods you will get <strong>zero</strong> points! In other words, do not just evaluate the whole sum once for each vertex &#8212; there is obviously a better way to do it!</p>
<hr />
<p>Note that the length of each edge is preserved <em>by construction</em> &#8212; after all, we build the curve out of segments that have the same length as in the previous curve! In other words, we get not only a curvature flow but an <em>isometric</em> curvature flow (in the smooth case, isometry is reflected in the fact that \((\cos\alpha,\sin\alpha)\) is always a unit vector).</p>
<p>Ok, sounds pretty good so far: we simply subtract some fraction of the curvature each vertex, and compute a couple cumulative sums. As an added bonus, we preserve length. Why haven&#8217;t people been doing this all along? The answer is: when something sounds too good to be true, it probably is!</p>
<p>In particular, let&#8217;s take a look at what happens when we work with a <em>closed curve</em>, i.e., a loop in the plane. If we make a completely arbitrary change to the curvature \(\kappa\), there&#8217;s no reason to expect that segments joined end-to-end will close back up. In other words, the final vertex may be somewhere different from where the inital vertex appeared:</p>
<p><a href="wp-content/uploads/2012/12/ddg_loop_closure.svg"><img class="aligncenter size-full wp-image-344" title="ddg_loop_closure" src="wp-content/uploads/2012/12/ddg_loop_closure.svg" alt="" /></a></p>
<p>A fancy way of describing this situation is to say that the tangents we recover from this procedure are not <em>integrable</em> &#8212; they do not &#8220;integrate up&#8221; to form a closed loop. Similarly, the curvature itself is not integrable: the cumulative curvature function \(\alpha\) does not describe the tangent direction of any closed loop. Why did this happen? Well, let&#8217;s go back and take a look at our condition on total curvature. We said that the curvature \(\kappa\) of any closed loop \(\gamma\) satisfies<br />
\[ \int_{0}^L \kappa\ ds = 2\pi k \]<br />
for some turning number \(k \in \mathbb{Z}\). Another way of saying the same thing is that the first and last tangents of our curve must match up: \(T(0) = T(L)\). But if we change \(\kappa\) arbitrarily, this condition will no longer hold.</p>
<hr />
<p><strong>Exercise 4.15</strong><br />
Suppose that at time zero, the curvature function \(\kappa\) on a smooth curve \(\gamma\) satisfies our condition on total curvature. Show that any change in curvature \(\dot{\kappa}\) orthogonal to the constant function \(1: [0,L] \rightarrow \mathbb{R}; s \mapsto 1\) with respect to the \(L^2\) inner product will preserve this condition.</p>
<hr />
<p>We also need a condition that ensures the endpoints will meet up, i.e., \(\gamma(0) = \gamma(L)\). Although we will not derive it here, this condition again turns out to have a simple form:<br />
\[ \int_0^L \kappa \gamma = 0; \]<br />
equivalently, \(\dot{\kappa}\) must be (\(L^2\)-)orthogonal to the \(x-\) and \(y-\) coordinate functions of the immersion. Overall, then, we&#8217;re saying that the change in curvature must avoid a three-dimensional linear subspace of directions:<br />
\[ \langle \dot{\kappa}, 1 \rangle = \langle \dot{\kappa}, \gamma_x \rangle = \langle \dot{\kappa}, \gamma_y \rangle = 0. \]<br />
Like convex-quadratic energies, linear constraints are particularly easy to work with &#8212; in the case of our flow, we can simply remove the component of \(\dot{\kappa}\) that sits in this &#8220;forbidden&#8221; space. More specifically, suppose that this space is spanned by an orthonormal basis \(\{c_i\}\). Then we can simply travel in the augmented direction<br />
\[ \dot{\kappa}_c = \dot{\kappa} - \sum_{i=1}^3 \langle \dot{\kappa}, \hat{c}_i \rangle \hat{c}_i. \]</p>
<p><a href="wp-content/uploads/2012/12/ddg_constraint_projection.svg"><img class="aligncenter size-full wp-image-345" title="ddg_constraint_projection" src="wp-content/uploads/2012/12/ddg_constraint_projection.svg" alt="" /></a></p>
<hr />
<p><strong>Coding 4.8</strong><br />
Implement the method <tt>IsometricWillmoreFlow1D::buildConstraints()</tt>, which constructs the three constraint directions \(1\), \(\gamma_x\), \(\gamma_y\) as dense column vectors.</p>
<hr />
<hr />
<p><strong>Coding 4.9</strong><br />
Implement the method <tt>IsometricWillmoreFlow1D::orthogonalizeConstraints()</tt>, which builds an orthonormal basis \(\{\hat{c}_1,\hat{c}_2,\hat{c}_3\}\) spanning the same space as the three constraint directions. <em>Hint: use the <a href="http://en.wikipedia.org/wiki/Gram‚ÄìSchmidt_process">Gram-Schmidt process</a> &#8212; remember to use the correct inner product!</em></p>
<hr />
<hr />
<p><strong>Coding 4.10</strong><br />
Implement the method <tt>IsometricWillmoreFlow::enforceConstraints()</tt>, which removes the forbidden directions from the flow using the orthogonal basis and the procedure outlined above. Try running the isometric Willmore flow (you can switch to this flow in the GUI either by right-clicking to get the contextual menu, or by hitting the &#8216;<tt>i</tt>&#8216; key). Report the maximum stable time step that can be achieved for each of the provided meshes. Does the flow preserve the turning number of each of the input curves? (In other words, did we faithfully capture the Whitney-Graustein theorem in the discrete setting?) Try running the flow with and without constraints (by modifying <tt>IsometricWillmoreFlow::enforceConstraints()</tt>). What happens if you turn off all the constraints? Is there a strict subset of the constraints that is sufficient to keep the loop closed, or are they all needed?</p>
<hr />
<p>One thing you might have noticed about this new flow is that, while it still smooths out the curve, it looks very different from the one you implemented in the <tt>WillmoreFlow1D</tt> class. Why is there a difference? In either case, aren&#8217;t we doing gradient descent on the same energy? Well, if you paid close attention, you might already know the answer: yes, the energy stays the same, but the <em>metric</em> we used to define the gradient is different! (And if you <em>really</em> paid close attention, you may even know how to modify the second flow to make it look like the first one &#8212; and how to implement it!) Beyond that, there are all sorts of nice ways to improve the algorithm that involve discrete Laplacians and Poisson equations and&#8230; you know what? You&#8217;ve worked hard enough already. Enjoy the break, and see you next year!</p>
<p>&nbsp;</p>
<p><strong>Skeleton code:</strong> <a href="wp-content/uploads/ddg_hw4_skeleton.zip">ddg_hw4_skeleton.zip</a></p>
                </div>
                <footer>
                                        December 6, 2012 |                                                                 Posted in: <a href="index.html@cat=3.html" title="View all posts in Homework" rel="category">Homework</a> |                                                             <a href="index.html@p=320.html#comments" class="comments-link"  title="Comment on Homework 4: Curvature Flow">8 Comments &#187;</a>                </footer>
            </article>
                                    <nav class="navigation">
            <div class="alignleft"></div>
        <div class="alignright"></div>
    </nav>        </div>
    <aside id="sidebar">
	<ul>
	    <li id="search-3" class="widget widget_search"><form role="search" method="get" id="searchform" action="index.html" >
	<div><label class="screen-reader-text" for="s">Search for:</label>
	<input type="text" value="" name="s" id="s" />
	<input type="submit" id="searchsubmit" value="Search" />
	</div>
	</form></li><li id="meta-3" class="widget widget_meta"><h3 class="widgettitle">Meta</h3>			<ul>
						<li><a href="wp-login.php.html">Log in</a></li>
			<li><a href="index.html@feed=rss2" title="Syndicate this site using RSS 2.0">Entries <abbr title="Really Simple Syndication">RSS</abbr></a></li>
			<li><a href="index.html@feed=comments-rss2" title="The latest comments to all posts in RSS">Comments <abbr title="Really Simple Syndication">RSS</abbr></a></li>
			<li><a href="http://wordpress.org/" title="Powered by WordPress, state-of-the-art semantic personal publishing platform.">WordPress.org</a></li>
						</ul>
</li><li id="pages-2" class="widget widget_pages"><h3 class="widgettitle">Pages</h3>		<ul>
			<li class="page_item page-item-4"><a href="index.html@page_id=4.html">Course Information</a></li>
<li class="page_item page-item-11"><a href="index.html@page_id=11.html">Homework Assignments</a></li>
<li class="page_item page-item-9"><a href="index.html@page_id=9.html">Lecture Slides</a></li>
<li class="page_item page-item-13"><a href="index.html@page_id=13.html">Subscriptions</a></li>
		</ul>
		</li><li id="categories-3" class="widget widget_categories"><h3 class="widgettitle">Categories</h3>		<ul>
	<li class="cat-item cat-item-4"><a href="index.html@cat=4.html" title="View all posts filed under Administration">Administration</a> (2)
</li>
	<li class="cat-item cat-item-3"><a href="index.html@cat=3.html" title="View all posts filed under Homework">Homework</a> (6)
</li>
	<li class="cat-item cat-item-5"><a href="index.html@cat=5.html" title="View all posts filed under Notes">Notes</a> (12)
</li>
		</ul>
</li><li id="categoryposts-3" class="widget widget_categoryposts"><h3 class="widgettitle">Course Notes</h3><ul>
		<li class="cat-post-item">
			<a class="post-title" href="index.html@p=104.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to the Geometry of Surfaces">A Quick and Dirty Introduction to the Geometry of Surfaces</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=139.html" rel="bookmark" title="Permanent link to Derivatives and Tangent Vectors">Derivatives and Tangent Vectors</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=162.html" rel="bookmark" title="Permanent link to The Fundamental Polygon">The Fundamental Polygon</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=187.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to the Geometry of Curves">A Quick and Dirty Introduction to the Geometry of Curves</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=214.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to the Curvature of Surfaces">A Quick and Dirty Introduction to the Curvature of Surfaces</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=235.html" rel="bookmark" title="Permanent link to Geometry in Coordinates">Geometry in Coordinates</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=262.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part I: Vectors and 1-Forms">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part I: Vectors and 1-Forms</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=272.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part II: Differential Forms and the Wedge Product">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part II: Differential Forms and the Wedge Product</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=294.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part III: Hodge Duality">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part III: Hodge Duality</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=296.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part IV: Differential Operators">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part IV: Differential Operators</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=298.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part V: Integration and Stokes&#8217; Theorem">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part V: Integration and Stokes&#8217; Theorem</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=307.html" rel="bookmark" title="Permanent link to Discrete Exterior Calculus">Discrete Exterior Calculus</a>
			
			
						
						
					</li>
	</ul>
</li>	</ul>
</aside></div><!-- id='content' -->
    </div><!-- id='wrapcontent' -->
    <div id="wrapfooter" class="wrapper">
    	<footer id="footer">
    		        	<p class="clear copy">
            	<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Introduction to Discrete Differential Geometry</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.        	</p>
    	</footer>
	</div>
</div>
</body>
</html>