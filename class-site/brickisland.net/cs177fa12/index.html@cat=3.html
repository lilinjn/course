<!DOCTYPE html>
<html dir="ltr" lang="en-US">
<head>
    <meta charset="UTF-8" />
    <title>Homework &raquo;  CS 177: Discrete Differential Geometry</title>
    <!--[if lt IE 9]>
    <script type="text/javascript" src="http://brickisland.net/cs177fa12/wp-content/themes/constructor/js/html5.js"></script>
    <![endif]-->
    <link rel="profile" href="http://gmpg.org/xfn/11" />
    <link rel="stylesheet" type="text/css" media="screen" href="wp-content/themes/constructor/style.css"/>
    <link rel="stylesheet" type="text/css" media="print" href="wp-content/themes/constructor/print.css" />
	<link rel="stylesheet" type="text/css" media="only screen and (max-device-width: 480px)" href="wp-content/themes/constructor/style-480.css" />
    <link rel="pingback" href="xmlrpc.php" />
    	<link rel='archives' title='December 2012' href='index.html@m=201212.html' />
	<link rel='archives' title='November 2012' href='index.html@m=201211.html' />
	<link rel='archives' title='October 2012' href='index.html@m=201210.html' />
    
<script type='text/x-mathjax-config'>
MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<link rel="alternate" type="application/rss+xml" title="CS 177: Discrete Differential Geometry &raquo; Feed" href="index.html@feed=rss2" />
<link rel="alternate" type="application/rss+xml" title="CS 177: Discrete Differential Geometry &raquo; Comments Feed" href="index.html@feed=comments-rss2" />
<link rel="alternate" type="application/rss+xml" title="CS 177: Discrete Differential Geometry &raquo; Homework Category Feed" href="index.html@feed=rss2&amp;cat=3" />
<link rel='stylesheet' id='constructor-style-css'  href='wp-content/uploads/constructor/cache/style.css' type='text/css' media='all' />
<link rel='stylesheet' id='constructor-theme-css'  href='wp-content/uploads/constructor/themes/current/style.css' type='text/css' media='all' />
<script type='text/javascript' src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#038;ver=3.4.2'></script>
<script type='text/javascript' src='wp-includes/js/jquery/jquery.js@ver=1.7.2'></script>
<script type='text/javascript' src='wp-content/themes/constructor/js/ready.js'></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="xmlrpc.php@rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="wp-includes/wlwmanifest.xml" /> 
<meta name="generator" content="WordPress 3.4.2" />
	<style type="text/css">.recentcomments a{display:inline !important;padding:0 !important;margin:0 !important;}</style>
</head>
<body class="archive category category-homework category-3">
	
<div id="body">
   <div id="wrapheader" class="wrapper">
       <header id="header">
                        <div id="title">
					
					<div id="name"><a href="index.html" title="CS 177: Discrete Differential Geometry &raquo; Caltech | Fall 2012 | Tue/Thu 10:30-11:55 | 314 ANB">CS 177: Discrete Differential Geometry</a></div>
				                <div id="description">Caltech | Fall 2012 | Tue/Thu 10:30-11:55 | 314 ANB</div>
            </div>
       </header>
   </div>
   
   <div id="wrapcontent" class="wrapper">
       <div id="content" class="box shadow opacity layout-right">
    <div id="container" >
                            <article class="post-320 post type-post status-publish format-standard hentry category-homework" id="post-320">
                <header class="opacity box">
                    <h2><a href="index.html@p=320.html" rel="bookmark" title="Permanent Link to Homework 4: Curvature Flow">Homework 4: Curvature Flow</a></h2>
                </header>
                <div class="entry">
                	<p><a href="wp-content/uploads/2012/12/ddg_curvature_flow.svg"><img class="aligncenter size-full wp-image-331" title="ddg_curvature_flow" src="wp-content/uploads/2012/12/ddg_curvature_flow.svg" alt="" /></a></p>
<p>In this homework we&#8217;ll take a closer look at <em>curvature flow</em>. We already saw one example of curvature flow (<em>mean</em> curvature flow) while studying the Poisson equation. The general idea behind curvature flow is that we have an <em>energy</em> \(E\) measuring the smoothness of our geometry, and can reduce this energy by traveling along the direction of steepest descent. Conceptually, you can imagine that \(E\) is some kind of potential &#8212; surfaces with many wrinkles have a lot of energy, and want to reduce this energy by &#8220;relaxing&#8221; into a smoother state. This description suggests a sort of &#8220;energy landscape,&#8221; where high peaks correspond to wrinkly surfaces and low valleys correspond to smooth ones. Here&#8217;s a two-dimensional cartoon of what this landscape might look like:</p>
<p><a href="wp-content/uploads/2012/12/ddg_energy_landscape.svg"><img class="aligncenter size-full wp-image-332" title="ddg_energy_landscape" src="wp-content/uploads/2012/12/ddg_energy_landscape.svg" alt="" /></a></p>
<p>To smooth out the geometry we can &#8220;ski&#8221; downhill, discovering a sequence of smoother and smoother surfaces along the way. Visually the effect is akin to a pat of butter slowly melting away on a hot piece of toast, or a water droplet buckling into a perfectly round sphere.</p>
<p>To be more concrete, let \(f\) be an immersion of a manifold \(M\) (e.g., a curve or surface) into Euclidean space, and suppose that \(E\) is a real-valued function of \(f\). Then a curvature flow is the solution to the partial differential equation<br />
\[ \dot{f} = -\nabla E(f) \]<br />
starting with some initial immersion \(f_0\), where \(\dot{f}\) denotes the derivative in time. In words, this equation just says that the difference in position of the surface at two consecutive points in time is equal to the change in position that reduces the energy quickest.</p>
<p>For surfaces, two common energies are the <em>Dirichlet energy</em><br />
\[ E_D(f) = \frac{1}{4} \int_M |\nabla f|^2 dA \]<br />
and the <em>Willmore energy</em><br />
\[ E_W(f) = \frac{1}{4} \int_M (\kappa_1 - \kappa_2)^2 dA. \]<br />
where as usual \(\kappa_1\) and \(\kappa_2\) are the principal curvatures induced by \(f\). Both energies somehow measure the &#8220;wrinkliness&#8221; of a surface, but how are they related?</p>
<hr />
<p><strong>Exercise 4.1</strong><br />
For a surface \(M\) without boundary show that, up to an additive constant, the Willmore energy can be expressed as<br />
\[ E_W = \int_M H^2\ dA \]<br />
and explain why this constant does not matter in the context of curvature flow. <em>Hint: Gauss-Bonnet.</em></p>
<hr />
<p>In other words, Dirichlet energy looks like the (squared) \(L^2\) norm of the gradient, whereas Willmore energy looks like the (squared) \(L^2\) norm of mean curvature. Superficially these quantities look quite different, but in fact they are quite similar!</p>
<hr />
<p><strong>Exercise 4.2</strong><br />
For a surface \(M\) without boundary show that (again up to constant factors)<br />
\[ E_D = \langle \Delta f, f \rangle, \]<br />
\[ E_W = \langle \Delta^2 f, f \rangle, \]<br />
<em>Hint: Green&#8217;s first identity and the definition of the mean curvature normal.</em></p>
<hr />
<p>From these expressions, it may appear that Dirichlet and Willmore energy are nice, simple, quadratic functions of \(f\). Don&#8217;t be fooled! The Laplace-Beltrami operator \(\Delta\) depends on the immersion \(f\) itself, which means that the corresponding gradient flows are rather nasty and nonlinear. Later on we&#8217;ll look at a couple ways to deal with this nonlinearity.</p>
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">Gradient Descent</span></strong></p>
<p>Now that have a couple energies to work with, how do we derive gradient flow? Previously we defined the gradient of a function \(\phi: \mathbb{R}^n \rightarrow \mathbb{R}\) as<br />
\[ \nabla\phi = \left[ \begin{array}{c} \partial\phi/\partial x^1 \\ \vdots \\ \partial\phi/\partial x^n \end{array} \right], \]<br />
i.e., as just a list of all the partial derivatives. This definition works pretty well when \(\phi\) is defined over a nice finite-dimensional vector space like \(\mathbb{R}^n\), but what about something more exotic like the Willmore energy, which operates on an infinite-dimensional vector space of functions? In general, the gradient of a function \(\phi\) at a point \(x\) can be defined as the unique vector \(\nabla \phi(x)\) satisfying<br />
\[ \langle \nabla \phi(x), u \rangle = \lim_{h \rightarrow 0} \frac{\phi(x+hu)-\phi(x)}{h}, \]<br />
for all vectors \(u\), where \(\langle \cdot, \cdot \rangle\) denotes the inner product on the vector space. In other words, taking the inner product with the gradient should yield the directional derivative in the specified direction. Notice that this definition actually serves as a <em>definition</em> of differentiability: a function is differentiable at \(x\) if and only if all directional derivatives can be characterized by a single vector \(\nabla\phi(x)\). Geometrically, then, differentiability means that if we &#8220;zoom in&#8221; far enough the function looks almost completely flat.</p>
<hr />
<p><strong>Exercise 4.3</strong><br />
Explain why the gradient is the direction of steepest ascent.</p>
<hr />
<hr />
<p><strong>Exercise 4.4</strong><br />
Consider the function<br />
\[ \phi: \mathbb{R}^2 \rightarrow \mathbb{R}; (x_1, x_2) \mapsto x_1^2 - x_2^2. \]<br />
Confirm that the gradient found using the expression above agrees with the usual gradient found via partial derivatives.</p>
<hr />
<hr />
<p><strong>Exercise 4.5</strong><br />
Let \(M\) be a surface without boundary. Assume that the Laplace-Beltrami operator \(\Delta\) is constant with respect to the immersion \(f\) and use our definition of \(\nabla\) above to show that<br />
\[ \nabla E_D(f) \approx HN. \]<br />
In other words, gradient flow on Dirichlet energy looks roughly like the mean curvature flow \(\dot{f} = -HN\) that we studied in the previous assignment.</p>
<hr />
<p>The approximate gradient \(HN\) might be called a <em>linearization</em> of the true gradient &#8212; in general the idea is that we keep some quantity or some piece of an equation fixed so that the rest comes out to be a nice linear expression. This trick can be quite helpful in a practical setting, but it is typically worth understanding where and how the approximation affects the final result.</p>
<p>One final thing to mull over is the fact that the gradient depends on our particular choice of inner product \(\langle \cdot, \cdot \rangle\), which appears on the left-hand side in our definition. Why does the inner product matter? Intuitively, the gradient picks out the direction in which the energy increases fastest. But what does &#8220;fastest&#8221; mean? For instance, if we use a vector of real numbers \(\mathsf{x} \in \mathbb{R}^m\) to encode the vertices of a discrete curve, then what we really care about is the energy increase with respect to a change in the length of the <em>curve</em> &#8212; not the Euclidean length of the vector \(\mathsf{x}\) itself. In terms of our energy landscape we end up with a picture like the one below &#8212; you can imagine, for instance, that arrows on the left have unit norm with respect to the standard Euclidean inner product whereas arrows on the right have unit norm with respect to the \(L^2\) inner product on our discrete curve. As a result, gradient descent will proceed along two different trajectories:</p>
<p><a href="wp-content/uploads/2012/12/ddg_gradient_metric.svg"><img class="aligncenter size-full wp-image-333" title="ddg_gradient_metric" src="wp-content/uploads/2012/12/ddg_gradient_metric.svg" alt="" /></a></p>
<hr />
<p><strong>Exercise 4.6</strong><br />
Consider an inner product \(\langle \cdot, \cdot \rangle\) on \(\mathbb{R}^n\) defined by a positive definite matrix \(\mathsf{B} \in \mathbb{R}^{n \times n}\), i.e., \(\langle u, v \rangle = \mathsf{u^T B v}\). Show that the gradient \(\nabla_B\) induced by this inner product is related to the standard gradient \(\nabla\) via<br />
\[ \nabla_\mathsf{B} = \mathsf{B}^{-1} \nabla. \]</p>
<hr />
<p>In the discrete setting, the matrix \(\mathsf{B}\) is sometimes referred to as the <em>mass matrix</em>, because it encodes the amount of &#8220;mass&#8221; each degree of freedom contributes to the total. When working with discrete differential forms, one possible choice mass matrix is given by (an appropriate constant multiple of) the diagonal Hodge star. This choice corresponds to applying piecewise-constant interpolation and then taking the usual \(L^2\) inner product. For instance, here&#8217;s what piecewise constant interpolation looks like for a primal 1-form on a triangulated surface &#8212; the integrated value stored on a given edge gets &#8220;spread out&#8221; over the so-called <em>diamond region</em> associated with that edge:</p>
<p><a href="wp-content/uploads/2012/12/ddg_piecewise_constant_interpolation.svg"><img class="aligncenter size-full wp-image-334" title="ddg_piecewise_constant_interpolation" src="wp-content/uploads/2012/12/ddg_piecewise_constant_interpolation.svg" alt="" /></a></p>
<p>In general, let \(\star_k\) be a real diagonal matrix with one entry for each \(k\)-dimensional simplex \(\sigma_i\). The nonzero entries are<br />
\[ \left( \star_k \right)_{ii} = \frac{|\sigma_i^\star|}{|\sigma_i|}, \]<br />
where \(\sigma_i^\star\) is the circumcentric dual of \(\sigma\), and \(|\cdot|\) denotes the (unsigned) volume. The corresponding mass matrix on primal discrete \(k\)-forms in \(n\) dimensions is then<br />
\[ B_k = \left( \begin{array}{c} n \\ k \end{array} \right) \star_k, \]<br />
i.e., a binomial coefficient times a (primal) diagonal Hodge star. The mass matrices for <em>dual</em> \(k\)-forms can likewise be expressed as constant multiples of the inverse:<br />
\[ B^\star_k = \left( \begin{array}{c} n \\ k \end{array} \right) \star_{n-k}^{-1}. \]<br />
These matrices will come in handy when deriving equations for discrete curvature flow.</p>
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">Flow on Curves</span></strong></p>
<p><a href="wp-content/uploads/2012/12/ddg_curve_energy.svg"><img class="aligncenter size-full wp-image-335" title="ddg_curve_energy" src="wp-content/uploads/2012/12/ddg_curve_energy.svg" alt="" /></a></p>
<p>For the remainder of this assignment, we&#8217;re going to make life simpler by working with planar curves instead of surfaces. As discussed earlier, we can describe the geometry of a curve via an immersion<br />
\[ \gamma: I \rightarrow \mathbb{R}^2; s \mapsto \gamma(s)\]<br />
of some interval \(I = [0,L] \subset \mathbb{R}\) into the Euclidean plane \(\mathbb{R}^2\). A common energy for curves is simply the integral of the curvature \(\kappa\), squared:<br />
\[ E(\gamma) = \int_0^L \kappa^2\ ds. \]<br />
Let&#8217;s first establish some facts about curvature in the smooth setting.</p>
<hr />
<p><strong>Exercise 4.7</strong><br />
The unit tangent field on a smooth curve \(\gamma\) can be expressed as \(T = (\cos\theta,\sin\theta)\) for some function \(\theta: I \rightarrow \mathbb{R}\). Show that the normal curvature can be expressed as<br />
\[ \kappa = d\theta(X) \]<br />
where \(X\) is a positively-oriented unit vector field. In other words, the scalar curvature is change in the direction of the tangent.</p>
<hr />
<hr />
<p><strong>Exercise 4.8</strong><br />
Explain in words why the total curvature of any closed immersed curve \(\gamma\) (whether discrete or not) is an integer multiple of \(2\pi\), i.e., \(\gamma(0) = \gamma(L)\)<br />
\[ \int_0^L \kappa ds = 2\pi k,\ k \in \mathbb{Z}. \]<br />
(The number \(k\) is called the <em>turning number</em> of the curve.)</p>
<hr />
<p>A stronger statement is the <em>Whitney-Graustein theorem</em> which says that the turning number of a curve will be preserved by any <em>regular homotopy</em>, i.e., by any continuous motion that keeps the curve immersed. For instance, here&#8217;s an example of a motion that is <em>not</em> a regular homotopy &#8212; note that the curve gets &#8220;pinched&#8221; into a sharp cusp halfway thorugh the motion, at which point the turning number goes from \(k=2\) to \(k=1\):</p>
<p><a href="wp-content/uploads/2012/12/ddg_irregular_homotopy.svg"><img class="aligncenter size-full wp-image-336" title="ddg_irregular_homotopy" src="wp-content/uploads/2012/12/ddg_irregular_homotopy.svg" alt="" /></a></p>
<p>We&#8217;ll keep these ideas in mind as we develop algorithms for curvature flow.</p>
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">Discrete Curves</span></strong></p>
<p>In the discrete setting, \(\gamma\) is simply a collection of line segments connecting a sequence of vertices with coordinates \( \gamma_1, \ldots, \gamma_n \in \mathbb{R}^2 \):</p>
<p><a href="wp-content/uploads/2012/12/ddg_discrete_curve.svg"><img class="aligncenter size-full wp-image-337" title="ddg_discrete_curve" src="wp-content/uploads/2012/12/ddg_discrete_curve.svg" alt="" /></a></p>
<p>Note that in the provided code framework, a curve is represented by a half edge mesh consisting of a single polygon. Therefore, to iterate over the curve you might write something like</p>
<p><code>
<pre>   FaceIter gamma = mesh.faces.begin();
    HalfEdgeIter he = gamma->he;
    do {
       // do something interesting here!
       he = he->next;
    }
    while( he != gamma->he );
</pre>
<p></code></p>
<p>As with surfaces, we can consider both a primal and dual &#8220;mesh&#8221; associated with this curve &#8212; this time, each primal edge is associated with a dual vertex at its midpoint, and each primal vertex is associated with a dual edge connecting the two adjacent dual vertices:</p>
<p><a href="wp-content/uploads/2012/12/ddg_simplicial_dual_1d.svg"><img class="aligncenter size-full wp-image-338" title="ddg_simplicial_dual_1d" src="wp-content/uploads/2012/12/ddg_simplicial_dual_1d.svg" alt="" /></a></p>
<p>In the language of discrete exterior calculus, then, \(\gamma \in (\mathbb{R}^2)^n\) is a \(\mathbb{R}^2\)-valued primal 0-form, i.e., a value associated with each vertex.</p>
<hr />
<p><strong>Exercise 4.9</strong><br />
Show that the nonzero entries of the diagonal Hodge star on primal 0-forms are given by<br />
\[ (\star_0)_{ii} = L_i, \]<br />
where<br />
\[ L_i = \frac{1}{2}( |\gamma_{i+1}-\gamma_i| + |\gamma_i-\gamma_{i-1}| ). \]</p>
<hr />
<hr />
<p><strong>Coding 4.1</strong><br />
Implement the methods <tt>Edge::length()</tt> and <tt>Vertex::dualLength()</tt>, which should return the primal edge length and the circumcentric dual edge length, respectively. (The latter should be a one-liner that just calls the former!) Finally, implement the method <tt>IsometricWillmoreFlow1D::buildMassMatrix()</tt>, which builds the diagonal Hodge star on primal 0-forms.</p>
<hr />
<hr />
<p><strong>Exercise 4.10</strong><br />
Show that on a discrete curve the total curvature along a dual edge \(e^\star_{ij}\) is equal to the exterior angle \(\varphi_{ij} \in \mathbb{R}\) at the corresponding vertex, i.e., the difference in angle between the two consecutive tangents:<br />
\[ \varphi_{ij} = \theta_j - \theta_i = \int_{e^\star_{ij}} \kappa\ ds. \]<br />
<em>(Hint: Stokes&#8217; theorem!)</em></p>
<hr />
<p>In other words, the exterior angle \(\varphi\) gives us the <em>integrated</em> curvature. Applying the discrete Hodge star yields <em>pointwise</em> curvatures \(\kappa\), which we will use as the degrees of freedom in our numerical curvature flow:<br />
\[ \kappa = \star\varphi. \]</p>
<hr />
<p><strong>Coding 4.2</strong><br />
Implement the method <tt>Vertex::curvature()</tt>, which returns the pointwise curvature as defined above. <em>Hint: in the language of discrete exterior calculus, what kind of quantity is \(\varphi\)? And what kind of quantity is \(\kappa\)?</em></p>
<hr />
<p>The next exercise should solidify your understanding of where all these different quantities live, and which operators take you back and forth from one space to another!</p>
<hr />
<p><strong>Exercise 4.11</strong><br />
Show that for a discrete curve \(E(\gamma)\) can be written explicitly as<br />
\[ E(\gamma) = \sum_i \varphi_i^2 / L_i, \]<br />
assuming we use piecewise constant interpolation of curvature.</p>
<hr />
<p>Now that we have a discrete curvature energy, let&#8217;s derive an expression for the gradient.</p>
<hr />
<p><strong>Exercise 4.12</strong></p>
<p>Let \(\varphi\) be the angle made by two vectors \(u,v \in \mathbb{R}^2\). Show that the gradient of \(\varphi\) with respect to \(u\) can be expressed as<br />
\[ \nabla_u \varphi = -\frac{v_{\perp u}}{2A} \]</p>
<p><a href="wp-content/uploads/2012/12/ddg_angle_gradient.svg"><img class="aligncenter size-full wp-image-339" title="ddg_angle_gradient" src="wp-content/uploads/2012/12/ddg_angle_gradient.svg" alt="" /></a></p>
<p>where \(v_{\perp u}\) denotes the component of \(v\) orthogonal to \(u\) and \(A\) is the area of a triangle with sides \(u\) and \(v\).</p>
<hr />
<hr />
<p><strong>Exercise 4.13</strong><br />
Let \(L\) be the length of a vector \(u = b-a\), where \(a\) and \(b\) are a pair of points in \(\mathbb{R}^2\). Show that<br />
\[ \nabla_a L = -\hat{u} \]<br />
and<br />
\[ \nabla_b L = \hat{u}. \]</p>
<p><a href="wp-content/uploads/2012/12/ddg_length_gradient.svg"><img class="aligncenter size-full wp-image-340" title="ddg_length_gradient" src="wp-content/uploads/2012/12/ddg_length_gradient.svg" alt="" /></a></p>
<hr />
<hr />
<p><strong>Exercise 4.14</strong><br />
Collecting the results of the past few exercises, show that the gradient of the \(i\)th term of our curvature energy<br />
\[ E_i = \varphi_i^2 / L_i \]<br />
with respect to vertex coordinates \(\gamma_{i-1}\), \(\gamma_i\), and \(\gamma_{i+1}\) is given explicitly by<br />
\[<br />
\begin{array}{rcr}<br />
\nabla_{\gamma_{i-1}} E_i &amp;=&amp; \frac{\varphi_i}{L_i L_{i-1}} \left( \frac{v_{\perp u}}{A_i} + \frac{\varphi_i}{2L_i} \hat{u} \right) \\<br />
\nabla_{\gamma_{i+1}} E_i &amp;=&amp; \frac{\varphi_i}{L_i^2} \left( \frac{u_{\perp v}-v_{\perp u}}{A_i} + \frac{\varphi_i}{2L_i} (\hat{v}-\hat{u}) \right) \\<br />
\nabla_{\gamma_i} E_i &amp;=&amp; -\frac{\varphi_i}{L_i L_{i+1}} \left( \frac{u_{\perp v}}{A_i} + \frac{\varphi_i}{2L_i} \hat{v} \right) \\<br />
\end{array}<br />
\]</p>
<p><a href="wp-content/uploads/2012/12/ddg_exterior_angle_gradient.svg"><img class="aligncenter size-full wp-image-341" title="ddg_exterior_angle_gradient" src="wp-content/uploads/2012/12/ddg_exterior_angle_gradient.svg" alt="" /></a></p>
<p>where \(\varphi_i\) is the exterior angle at vertex \(i\), \(L_i\) is the dual edge length, and \(A_i\) is the area of a triangle with edges \(u = \gamma_i-\gamma_{i-1}\) and \(v = \gamma_{i+1}-\gamma_i\). The gradient of \(E_i\) with respect to all other vertices \(\gamma_j\) is zero. Why? <em>(Hint: remember to take the gradient with respect to the right metric!)</em></p>
<hr />
<hr />
<p><strong>Coding 4.3</strong><br />
Implement the method <tt>WillmoreFlow1D::computeGradient()</tt> using the expressions above. The gradient of energy with respect to a given vertex should be stored in the member <tt>Vertex::energyGradient</tt>. Remember that the overall energy is a <em>sum</em> over the terms \(E_i\), which means you will need to add up the contributions to the gradient at each vertex.</p>
<hr />
<hr />
<p><strong>Coding 4.4</strong><br />
Implement the method <tt>WillmoreFlow1D::integrate()</tt>, which should integrate the flow equation<br />
\[ \dot{\gamma} = -\nabla E(\gamma) \]<br />
using the forward Euler scheme. (See the end of the previous assignment for a brief discussion of time integration.) Run the code on the provided meshes, and report the maximum stable time step in each case, i.e., the largest time step for which the flow succeeds at smoothing out the curve. (The time step size can be adjusted using the keys &#8216;<tt>-</tt>&#8216;, &#8216;<tt>=</tt>&#8216;, &#8216;<tt>\_</tt>&#8216;, and &#8216;<tt>+</tt>.&#8217;)</p>
<hr />
<p>&nbsp;</p>
<p><strong><span style="text-decoration: underline;">Curvature Flow in Curvature Space</span></strong></p>
<p>If you feel exhausted at this point in the assignment, you&#8217;re not alone! Taking derivatives by hand can be a royal pain (and it gets even worse when you want second derivatives, which are required for more sophisticated algorithms like Newton descent). But it&#8217;s worth grinding out this kind of expression at least once in your life so that you really understand what&#8217;s involved. In practice there are a variety of alternatives, including <a href="http://en.wikipedia.org/wiki/Numerical_differentiation">numerical differentiation</a>, <a href="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>, and <a href="http://en.wikipedia.org/wiki/Symbolic_differentiation">symbolic differentiation</a> &#8212; these methods all have their place, and it&#8217;s well-worth understanding the tradeoffs they offer in terms of accuracy, efficiency, and code complexity.</p>
<p>But before getting mired in the bedraggled business of computer-based derivatives, it&#8217;s worth realizing that there is a tantalizing fourth alternative: come up with a simpler formulation of your problem! In particular, the mention of a <em>convex-quadratic energy</em> should make your mouth water and your heart beat faster, since these things make your life easier in a number of ways. &#8220;Convex-quadratic&#8221; means that your energy can be expressed as a real-valued homogeneous quadratic polynomial, i.e., as<br />
\[ E(x) = \langle Ax, x \rangle \]<br />
for some positive-semidefinite self-adjoint linear operator \(A\) that does not depend whatsoever on the argument \(x\). For instance, suppose that in the discrete setting the degrees of freedom \(x\) of our system are encoded by a vector \(\mathsf{x} \in \mathbb{R}^n\). Then a quadratic energy can always be represented as<br />
\[ E(x) = \mathsf{x^T A x} \]<br />
for some fixed symmetric positive-semidefinite matrix \(\mathsf{A} \in \mathbb{R}^{n \times n}\). Earlier we visualized definiteness in terms of the graph of the energy in two dimensions:</p>
<p><a href="wp-content/uploads/2012/12/ddg_definiteness.svg"><img class="aligncenter size-full wp-image-342" title="ddg_definiteness" src="wp-content/uploads/2012/12/ddg_definiteness.svg" alt="" /></a></p>
<p>Independent of definiteness, the gradient of a quadratic energy has a simple <em>linear</em> expression<br />
\[ \nabla E(x) = 2\mathsf{B^{-1}Ax}, \]<br />
where the matrix \(\mathsf{B} \in \mathbb{R}^{n \times n}\) encodes the inner product. This setup not only simplifies the business of taking derivatives, but also makes things inexpensive to evaluate at the numerical level &#8212; for instance, we can apply the backward Euler method by just solving a linear system, instead of performing some kind of nasty nonlinear root finding. Moreover, since the matrix \(\mathsf{A}\) is constant, we can save a lot of computation by prefactoring it once and applying backsubstitution many times. This setup also has some nice analytical features. For one thing, any local minimum of a convex energy is guaranteed to be a global minimum, which means that gradient descent will ultimately lead to an optimal solution. For another, there is an extremely well-established theory of linear PDEs, which allows one to easily answer questions about things like numerical stability. In contrast, <a href="http://mathoverflow.net/questions/15292/why-cant-there-be-a-general-theory-of-nonlinear-pde">the general theory of nonlinear PDEs is kind of a zoo</a>.</p>
<p>Ok, enough religion! Let&#8217;s see how a quadratic formulation can help us with the specific problem of curvature flow. Actually, we already have a quadratic energy &#8212; it&#8217;s<br />
\[ E(\kappa) = \int_0^L \kappa^2 ds. \]<br />
The only difference between this energy and the one we&#8217;ve been working with all along is that it&#8217;s a function of the curvature \(\kappa\) rather than the immersion \(f\) &#8212; as a result, we avoid all the nonlinearity associated with expressing \(\kappa\) in terms of \(f\). More concretely, at the discrete level we&#8217;re going to store and manipulate a single number \(\kappa_i\) at each vertex, rather than computing it indirectly from the vertex coordinates \(\gamma_i \in \mathbb{R}^2\).</p>
<hr />
<p><strong>Coding 4.5</strong><br />
Implement the method <tt>IsometricWillmoreFlow1D::getCurvature()</tt>, which simply evaluates the (pointwise) curvature at each vertex and stores it in the member <tt>Vertex::kappa</tt>. This method should call <tt>Vertex::curvature()</tt>.</p>
<hr />
<p>One nice consequence of this setup is that the gradient becomes extremely simple! Taking the gradient with respect to the \(L^2\) inner product on 0-forms, we get<br />
\[ \nabla E(\kappa) = -2\kappa. \]<br />
Gradient flow then becomes a simple, linear equation involving no spatial derivatives:<br />
\[ \dot{\kappa} = -2\kappa. \]</p>
<hr />
<p><strong>Coding 4.6</strong><br />
Implement the methods <tt>IsometricWillmoreFlow1D::computeFlowDirection()</tt> and <tt>IsometricWillmoreFlow1D::integrate()</tt>, which integrate the above flow equation using the forward Euler scheme. <em>Hint: this step should be very easy!</em></p>
<hr />
<p>If we want to actually draw the curve, we can integrate curvature to get tangents, then integrate tangents to get positions. In other words, we can recover the direction \(\theta\) of the tangent via<br />
\[ \theta(s) = \theta_0 + \int_0^s d\theta = \theta_0 + \int_0^s \kappa\ ds, \]<br />
where \(\theta_0\) specifies the direction of the first tangent on our curve. The tangent vectors themselves are given by \(T(s) = (\cos\theta(s),\sin\theta(s))\) as before. Once we have the tangents, we can recover the immersion itself via<br />
\[ f(s) = f_0 + \int_I T(s)\ ds, \]<br />
where again \(f_0\) specifies a &#8220;starting point&#8221; for the curve. In the discrete setting, these two steps correspond to a very simple reconstruction procedure: start out at some initial vertex and join the edges end to end, rotating by the exterior angles \(\varphi_i\) at each step:</p>
<p><a href="wp-content/uploads/2012/12/ddg_curve_reconstruction.svg"><img class="aligncenter size-full wp-image-343" title="ddg_curve_reconstruction" src="wp-content/uploads/2012/12/ddg_curve_reconstruction.svg" alt="" /></a></p>
<p>More explicitly, let<br />
\[ \theta_i = \sum_{k=0}^i \varphi_k \]<br />
and let<br />
\[ T_i = L_i (\cos\theta_i,\sin\theta_i), \]<br />
where \(L_i\) is the length of the \(i\)th primal edge. Then the vertex positions along the curve can be recovered via<br />
\[ \gamma_i = \sum_{k=0}^i T_k, \]<br />
mirroring the continuous formulae above. (Some questions to ponder: can you interpret these sums as piecewise integrals? What kind of quantity is \((\cos\varphi_i,\sin\varphi_i)\)? What kind of quantity is \(T_i\)? What&#8217;s the relationship between the two?)</p>
<hr />
<p><strong>Coding 4.7</strong><br />
Implement the methods <tt>IsometricWillmoreFlow1D::recoverTangents()</tt> and <tt>IsometricWillmoreFlow1D::recoverPositions()</tt>, which should compute the values \(T_i\) and \(\gamma_i\), respectively. If you use an \(O(n^2)\) algorithm to implement either of these methods you will get <strong>zero</strong> points! In other words, do not just evaluate the whole sum once for each vertex &#8212; there is obviously a better way to do it!</p>
<hr />
<p>Note that the length of each edge is preserved <em>by construction</em> &#8212; after all, we build the curve out of segments that have the same length as in the previous curve! In other words, we get not only a curvature flow but an <em>isometric</em> curvature flow (in the smooth case, isometry is reflected in the fact that \((\cos\alpha,\sin\alpha)\) is always a unit vector).</p>
<p>Ok, sounds pretty good so far: we simply subtract some fraction of the curvature each vertex, and compute a couple cumulative sums. As an added bonus, we preserve length. Why haven&#8217;t people been doing this all along? The answer is: when something sounds too good to be true, it probably is!</p>
<p>In particular, let&#8217;s take a look at what happens when we work with a <em>closed curve</em>, i.e., a loop in the plane. If we make a completely arbitrary change to the curvature \(\kappa\), there&#8217;s no reason to expect that segments joined end-to-end will close back up. In other words, the final vertex may be somewhere different from where the inital vertex appeared:</p>
<p><a href="wp-content/uploads/2012/12/ddg_loop_closure.svg"><img class="aligncenter size-full wp-image-344" title="ddg_loop_closure" src="wp-content/uploads/2012/12/ddg_loop_closure.svg" alt="" /></a></p>
<p>A fancy way of describing this situation is to say that the tangents we recover from this procedure are not <em>integrable</em> &#8212; they do not &#8220;integrate up&#8221; to form a closed loop. Similarly, the curvature itself is not integrable: the cumulative curvature function \(\alpha\) does not describe the tangent direction of any closed loop. Why did this happen? Well, let&#8217;s go back and take a look at our condition on total curvature. We said that the curvature \(\kappa\) of any closed loop \(\gamma\) satisfies<br />
\[ \int_{0}^L \kappa\ ds = 2\pi k \]<br />
for some turning number \(k \in \mathbb{Z}\). Another way of saying the same thing is that the first and last tangents of our curve must match up: \(T(0) = T(L)\). But if we change \(\kappa\) arbitrarily, this condition will no longer hold.</p>
<hr />
<p><strong>Exercise 4.15</strong><br />
Suppose that at time zero, the curvature function \(\kappa\) on a smooth curve \(\gamma\) satisfies our condition on total curvature. Show that any change in curvature \(\dot{\kappa}\) orthogonal to the constant function \(1: [0,L] \rightarrow \mathbb{R}; s \mapsto 1\) with respect to the \(L^2\) inner product will preserve this condition.</p>
<hr />
<p>We also need a condition that ensures the endpoints will meet up, i.e., \(\gamma(0) = \gamma(L)\). Although we will not derive it here, this condition again turns out to have a simple form:<br />
\[ \int_0^L \kappa \gamma = 0; \]<br />
equivalently, \(\dot{\kappa}\) must be (\(L^2\)-)orthogonal to the \(x-\) and \(y-\) coordinate functions of the immersion. Overall, then, we&#8217;re saying that the change in curvature must avoid a three-dimensional linear subspace of directions:<br />
\[ \langle \dot{\kappa}, 1 \rangle = \langle \dot{\kappa}, \gamma_x \rangle = \langle \dot{\kappa}, \gamma_y \rangle = 0. \]<br />
Like convex-quadratic energies, linear constraints are particularly easy to work with &#8212; in the case of our flow, we can simply remove the component of \(\dot{\kappa}\) that sits in this &#8220;forbidden&#8221; space. More specifically, suppose that this space is spanned by an orthonormal basis \(\{c_i\}\). Then we can simply travel in the augmented direction<br />
\[ \dot{\kappa}_c = \dot{\kappa} - \sum_{i=1}^3 \langle \dot{\kappa}, \hat{c}_i \rangle \hat{c}_i. \]</p>
<p><a href="wp-content/uploads/2012/12/ddg_constraint_projection.svg"><img class="aligncenter size-full wp-image-345" title="ddg_constraint_projection" src="wp-content/uploads/2012/12/ddg_constraint_projection.svg" alt="" /></a></p>
<hr />
<p><strong>Coding 4.8</strong><br />
Implement the method <tt>IsometricWillmoreFlow1D::buildConstraints()</tt>, which constructs the three constraint directions \(1\), \(\gamma_x\), \(\gamma_y\) as dense column vectors.</p>
<hr />
<hr />
<p><strong>Coding 4.9</strong><br />
Implement the method <tt>IsometricWillmoreFlow1D::orthogonalizeConstraints()</tt>, which builds an orthonormal basis \(\{\hat{c}_1,\hat{c}_2,\hat{c}_3\}\) spanning the same space as the three constraint directions. <em>Hint: use the <a href="http://en.wikipedia.org/wiki/Gram‚ÄìSchmidt_process">Gram-Schmidt process</a> &#8212; remember to use the correct inner product!</em></p>
<hr />
<hr />
<p><strong>Coding 4.10</strong><br />
Implement the method <tt>IsometricWillmoreFlow::enforceConstraints()</tt>, which removes the forbidden directions from the flow using the orthogonal basis and the procedure outlined above. Try running the isometric Willmore flow (you can switch to this flow in the GUI either by right-clicking to get the contextual menu, or by hitting the &#8216;<tt>i</tt>&#8216; key). Report the maximum stable time step that can be achieved for each of the provided meshes. Does the flow preserve the turning number of each of the input curves? (In other words, did we faithfully capture the Whitney-Graustein theorem in the discrete setting?) Try running the flow with and without constraints (by modifying <tt>IsometricWillmoreFlow::enforceConstraints()</tt>). What happens if you turn off all the constraints? Is there a strict subset of the constraints that is sufficient to keep the loop closed, or are they all needed?</p>
<hr />
<p>One thing you might have noticed about this new flow is that, while it still smooths out the curve, it looks very different from the one you implemented in the <tt>WillmoreFlow1D</tt> class. Why is there a difference? In either case, aren&#8217;t we doing gradient descent on the same energy? Well, if you paid close attention, you might already know the answer: yes, the energy stays the same, but the <em>metric</em> we used to define the gradient is different! (And if you <em>really</em> paid close attention, you may even know how to modify the second flow to make it look like the first one &#8212; and how to implement it!) Beyond that, there are all sorts of nice ways to improve the algorithm that involve discrete Laplacians and Poisson equations and&#8230; you know what? You&#8217;ve worked hard enough already. Enjoy the break, and see you next year!</p>
<p>&nbsp;</p>
<p><strong>Skeleton code:</strong> <a href="wp-content/uploads/ddg_hw4_skeleton.zip">ddg_hw4_skeleton.zip</a></p>
                </div>
                <footer>
                                        December 6, 2012 |                                                                 Posted in: <a href="index.html@cat=3.html" title="View all posts in Homework" rel="category">Homework</a> |                                                             <a href="index.html@p=320.html#comments" class="comments-link"  title="Comment on Homework 4: Curvature Flow">8 Comments &#187;</a>                </footer>
            </article>
                                <article class="post-302 post type-post status-publish format-standard hentry category-homework" id="post-302">
                <header class="opacity box">
                    <h2><a href="index.html@p=302.html" rel="bookmark" title="Permanent Link to Homework 3: The Discrete Laplacian">Homework 3: The Discrete Laplacian</a></h2>
                </header>
                <div class="entry">
                	<p>In the course notes we mentioned that the <em><a title="A Quick and Dirty Introduction to Exterior Calculus — Part IV: Differential Operators" href="index.html@p=296.html">Laplace-Beltrami operator</a></em> (more commonly known as just the <em>Laplacian</em>) plays a fundamental role in a variety of geometric and physical equations. In this homework we&#8217;ll put the Laplacian to work by coming up with a discrete version for triangulated surfaces. Similar to the homework on vertex normals, we&#8217;ll see that the same discrete expression for the Laplacian (via the <em>cotan formula</em>) arises from two very different ways of looking at the problem: using <em>test functions</em> (often known as <em>Galerkin projection</em>), or by integrating differential forms (often called <em>discrete exterior calculus</em>).</p>
<p><strong><span style="text-decoration: underline;">Poisson Equations</span></strong></p>
<p>Before we start talking about discretization, let&#8217;s establish a few basic facts about the Laplace operator \(\Delta\) and the standard <em>Poisson problem</em></p>
<p>\[ \Delta \phi = \rho. \]</p>
<p>Poisson equations show up all over the place &#8212; for instance, in physics \(\rho\) might represent a mass density in which case the solution \(\phi\) would (up to suitable constants) give the corresponding gravitational potential. Similarly, if \(\rho\) describes an charge density then \(\phi\) gives the corresponding electric potential (you&#8217;ll get to play around with these equations in the code portion of this assignment). In geometry processing a surprising number of things can be done by solving a Poisson equation (e.g., smoothing a surface, computing a vector field with prescribed singularities, or even computing the geodesic distance on a surface).</p>
<p>Often we&#8217;ll be interested in solving Poisson equations on a compact surface \(M\) without boundary.</p>
<p><strong>Exercise 3.1:</strong> A twice-differentiable function \(\phi: M \rightarrow \mathbb{R}\) is called <em>harmonic</em> if it sits in the kernel of the Laplacian, i.e., \(\Delta \phi = 0\). Argue that the <em>only</em> harmonic functions on a compact domain without boundary are the <em>constant</em> functions. (This argument does not have to be incredibly formal &#8212; there are a just couple simple observations that capture the main idea.)</p>
<p>This fact is quite important because it means we can add a constant to any solution to a Poisson equation. In other words, if \(\phi\) satisfies \(\Delta \phi = \rho\), then so does \(\phi+c\) since \(\Delta(\phi+c) = \Delta\phi + \Delta c = \Delta\phi + 0 = \rho\).</p>
<p><strong>Exercise 3.2:</strong> A separate fact is that on a compact domain without boundary, constant functions are not in the image of \(\Delta\). In other words, there is no function \(\phi\) such that \(\Delta \phi = c\). Why?</p>
<p>This fact is also important because it tells us when a given Poisson equation admits a solution. In particular, if \(\rho\) has a constant component then the problem is not well-posed. In some situations, however, it may make sense to simply remove the constant component. I.e., instead of trying to solve \(\Delta \phi = \rho\) one can solve \(\Delta \phi = \rho &#8211; \bar{\rho}\), where \(\bar{\rho} := \int_M \rho\ dV / |M| \) and \(|M|\) is the total volume of \(M\). However, you <em>must</em> be certain that this trick makes sense in the context of your particular problem!</p>
<p>When working with PDEs like the Poisson equation, it&#8217;s often useful to have an <em>inner product</em> between functions. An extremely common inner product is the <em>\(L^2\) inner product</em> \(\langle \cdot, \cdot \rangle\), which takes the integral of the pointwise product of two functions over the entire domain \(\Omega\):</p>
<p>\[ \langle f, g \rangle := \int_\Omega f(x) g(x) dx. \]</p>
<p>In spirit, this operation is similar to the usual <em>dot product</em> on \(\mathbb{R}^n\): it measures the degree to which two functions &#8220;line up.&#8221; For instance, the top two functions have a large inner product; the bottom two have a smaller inner product (as indicated by the dark blue regions):</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_l2_inner_product.svg"><img class="aligncenter size-full wp-image-310" title="ddg_l2_inner_product" src="../cs177/wp-content/uploads/2011/11/ddg_l2_inner_product.svg" alt="" /></a></p>
<p>Similarly, for two vector fields \(X\) and \(Y\) we can define an \(L^2\) inner product</p>
<p>\[ \langle X, Y \rangle := \int_\Omega X(x) \cdot Y(x) dx \]</p>
<p>which measures how much the two fields &#8220;line up&#8221; at each point.</p>
<p>Using the \(L^2\) inner product we can express an important relationship known as <em>Green&#8217;s first identity</em>. Green&#8217;s identity says that for any sufficiently differentiable functions \(f\) and \(g\)</p>
<p>\[ \langle \Delta f, g \rangle = -\langle \nabla f, \nabla g \rangle + \langle N \cdot \nabla f, g \rangle_\partial, \]</p>
<p>where \(\langle \cdot, \cdot \rangle_\partial\) denotes the inner product on the boundary and \(N\) is the outward unit normal.</p>
<p><strong>Exercise 3.3:</strong> Using exterior calculus, show that Green&#8217;s identity holds. Hint: apply Stokes&#8217; theorem to the 1-form \(g df\).</p>
<p>One last key fact about the Laplacian is that it is <em>positive-semidefinite</em>, i.e., \(\Delta\) satisfies</p>
<p>\[ \langle \Delta \phi, \phi \rangle \geq 0 \]</p>
<p>for all functions \(\phi\). (By the way, why isn&#8217;t this quantity <em>strictly</em> greater than zero?) Words cannot express the importance of positive-(semi)definiteness. Let&#8217;s think about a very simple example: functions of the form \(\phi(x,y) = ax^2 + bxy + cy^2\) in the plane. Any such function can also be expressed in matrix form:</p>
<p>\[ \phi(x,y) = \underbrace{\left[ \begin{array}{cc} x &amp; y \end{array} \right]}_{\mathbf{x}^T} \underbrace{\left[ \begin{array}{cc} a &amp; b/2 \\ b/2 &amp; c \end{array} \right]}_{A} \underbrace{\left[ \begin{array}{c} x \\ y \end{array} \right]}_{\mathbf{x}} = ax^2 + bxy + cy^2, \]</p>
<p>and we can likewise define positive-semidefiniteness for \(A\). But what does it actually look like? It looks like this &#8212; positive-definite matrices (\(\mathbf{x}^T A \mathbf{x} &gt; 0\)) look like a bowl, positive-semidefinite matrices (\(\mathbf{x}^T A \mathbf{x} \geq 0\)) look like a half-cylinder, and indefinite matrices (\(\mathbf{x}^T A \mathbf{x}\) might be positive or negative depending on \(\mathbf{x}\)) look like a saddle:</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_definiteness.svg"><img class="aligncenter size-full wp-image-311" title="ddg_definiteness" src="../cs177/wp-content/uploads/2011/11/ddg_definiteness.svg" alt="" /></a></p>
<p>Now suppose you&#8217;re a back country skiier riding down this kind of terrain in the middle of a howling blizzard. You&#8217;re cold and exhausted, and you know you parked your truck in a place where the ground levels out, but where exactly is it? The snow is blowing hard and visibility is low &#8212; all you can do is keep your fingers crossed and follow the slope of the mountain as you make your descent. (Trust me: this is really how one feels when doing numerical optimization!) If you were smart and went skiing in Pos Def Valley then you can just keep heading down and will soon arrive safely back at the truck. But maybe you were feeling a bit more adventurous that day and took a trip to Semi Def Valley. In that case you&#8217;ll still get to the bottom, but may have to hike back and forth along the length of the valley before you find your car. Finally, if your motto is &#8220;safety second&#8221; then you threw caution to the wind and took a wild ride in Indef Valley. In this case you may never make it home!</p>
<p>In short: positive-definite matrices are nice because it&#8217;s easy to find the minimum of the quadratic functions they describe &#8212; many tools in numerical linear algebra are based on this idea. Same goes for positive definite <em>linear operators</em> like the Laplacian, which can often be thought of as sort of infinite-dimensional matrices (if you took some time to read about the <a href="http://en.wikipedia.org/wiki/Spectral_theorem">spectral theorem</a>, you&#8217;ll know that this analogy runs even deeper, especially on compact domains). Given the ubiquity of Poisson equations in geometry and physics, it&#8217;s a damn good thing \(\Delta\) is positive-semidefinite!</p>
<p><strong>Exercise 3.4:</strong> Using Green&#8217;s first identity, show that \(\Delta\) is negative-semidefinite on any compact surface \(M\) without boundary. From a practical perspective, why are negative semi-definite operators just as good as positive semi-definite ones?</p>
<p><strong><span style="text-decoration: underline;">Test Functions</span></strong></p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_fem_basis.svg"><img class="aligncenter size-full wp-image-312" title="ddg_fem_basis" src="../cs177/wp-content/uploads/2011/11/ddg_fem_basis.svg" alt="" /></a></p>
<p>The solution to a geometric or physical problem is often described by a <em>function</em>: the temperature at each point on the Earth, the curvature at each point on a surface, the amount of light hitting each point of your retina, etc. Yet the space of <em>all possible</em> functions is mind-bogglingly large &#8212; too large to be represented on a computer. The basic idea behind the <em>finite element method</em> is to pick a smaller set of functions and try to find the best possible solution from within this set. More specifically, if \(u\) is the true solution to a problem and \(\{\phi_i\}\) is a collection of <em>basis functions</em>, then we seek the linear combination of these functions</p>
<p>\[ \tilde{u} = \sum_i x_i \phi_i,\ x_i \in \mathbb{R} \]</p>
<p>such that the difference \(||\tilde{u}-u||\) is as small as possible with respect to some norm. (Above we see a detailed curve \(u\) and its best approximation \(\tilde{u}\) by a collection of bump-like basis functions \(\phi_i\).)</p>
<p>Let&#8217;s start out with a very simple question: suppose we have a vector \(v \in \mathbb{R}^3\), and want to find the best approximation \(\tilde{v}\) within a plane spanned by two basis vectors \(e_1, e_2 \in \mathbb{R}^3\):</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_solution_space.svg"><img class="aligncenter size-full wp-image-313" title="ddg_solution_space" src="../cs177/wp-content/uploads/2011/11/ddg_solution_space.svg" alt="" /></a></p>
<p>Since \(\tilde{v}\) is forced to stay in the plane, the best we can do is make sure there&#8217;s error <em>only</em> in the normal direction. In other words, we want the error \(\tilde{v} &#8211; v\) to be orthogonal to both basis vectors \(e_1\) and \(e_2\):</p>
<p>\[<br />
\begin{array}{rcl}<br />
(\tilde{v} - v) \cdot e_1 &amp;=&amp; 0, \\<br />
(\tilde{v} - v) \cdot e_2 &amp;=&amp; 0. \\<br />
\end{array}<br />
\]</p>
<p>In this case we get a system of two linear equations for two unknowns, and can easily compute the optimal vector \(\tilde{v}\).</p>
<p>Now a harder question: suppose we want to solve a standard Poisson problem</p>
<p>\[ \Delta u = f. \]</p>
<p>How do we check whether a given function \(\tilde{u}\) is the best possible solution? The basic picture still applies, except that our bases are now <em>functions</em> \(\phi\) instead of finite-dimensional vectors \(e_i\), and the simple vector dot product \(\cdot\) gets replaced by the <em>\(L^2\) inner product</em>. Unfortunately, when trying to solve a Poisson equation we don&#8217;t know what the correct solution \(u\) looks like (otherwise we&#8217;d be done already!). So instead of the error \(\tilde{u} &#8211; u\), we&#8217;ll have to look at the <em>residual</em> \(\Delta \tilde{u} &#8211; f\), which measures how closely \(\tilde{u}\) satisfies our original equation. In particular, we want to &#8220;test&#8221; that the residual vanishes along each basis direction \(\phi_j\):</p>
<p>\[ \langle \Delta \tilde{u} - f, \phi_j \rangle = 0, \]</p>
<p>again resulting in a system of linear equations. This condition ensures that the solution behaves just as the true solution would over a large collection of possible &#8220;measurements.&#8221;</p>
<p>Next, let&#8217;s work out the details of this system for a triangulated surface. The most natural choice of basis functions are the piecewise linear <em>hat functions</em> \(\phi_i\), which equal one at their associated vertex and zero at all other vertices:</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_hat_function.svg"><img class="aligncenter size-full wp-image-314" title="ddg_hat_function" src="../cs177/wp-content/uploads/2011/11/ddg_hat_function.svg" alt="" /></a></p>
<p>At this point you might object: if all our functions are piecewise linear, and \(\Delta\) is a <em>second</em> derivative, aren&#8217;t we just going to get zero every time we evaluate \(\Delta u\)? Fortunately we&#8217;re saved by Green&#8217;s identity &#8212; let&#8217;s see what happens if we apply this identity to our triangle mesh, by breaking up the integral into a sum over individual triangles \(\sigma\):</p>
<p>\[<br />
\begin{array}{rcl}<br />
\langle \Delta u, \phi_j \rangle<br />
&amp;=&amp; \sum_k \langle \Delta u, \phi_j \rangle_{\sigma_k} \\<br />
&amp;=&amp; \sum_k \langle \nabla u, \nabla \phi_j \rangle_{\sigma_k} + \sum_k \langle N \cdot \nabla u, \phi_j \rangle_{\partial\sigma_k}. \\<br />
\end{array}<br />
\]</p>
<p>If the mesh has no boundary then this final sum will disappear since the normals of adjacent triangles are oppositely oriented, hence the boundary integrals along shared edges cancel each-other out:</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_greensidentity_cancellation.svg"><img class="aligncenter size-full wp-image-315" title="ddg_greensidentity_cancellation" src="../cs177/wp-content/uploads/2011/11/ddg_greensidentity_cancellation.svg" alt="" /></a></p>
<p>In this case, we&#8217;re left with simply</p>
<p>\[ \langle \nabla u, \nabla \phi_j \rangle \]</p>
<p>in each triangle \(\sigma_k\). In other words, we can &#8220;test&#8221; \(\Delta u\) as long as we can compute the gradients of both the candidate solution \(u\) and each basis function \(\phi_j\). But remember that \(u\) is itself a linear combination of the bases \(\phi_i\), so we have</p>
<p>\[ \langle \nabla u, \nabla \phi_j \rangle = \left\langle \nabla \sum_i x_i \phi_i, \nabla \phi_j \right\rangle = \sum_i x_i \langle \nabla \phi_i, \nabla \phi_j \rangle. \]</p>
<p>The critical thing now becomes the inner product between the gradients of the basis functions in each triangle. If we can compute these, then we can simply build the matrix</p>
<p>\[ A_{ij} := \langle \nabla \phi_i, \nabla \phi_j \rangle \]</p>
<p>and solve the problem</p>
<p>\[ A x = b \]</p>
<p>for the coefficients \(x\), where the entries on the right-hand side are given by \(b_i = \langle f, \phi_i \rangle\) (i.e., we just take the same &#8220;measurements&#8221; on the right-hand side).</p>
<p><strong>Exercise 3.5:</strong> Show that the aspect ratio of a triangle can be expressed as the sum of the cotangents of the interior angles at its base, i.e.,</p>
<p>\[ \frac{w}{h} = \cot{\alpha} + \cot{\beta}. \]</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_triangle_ratio_cotans.svg"><img class="aligncenter size-full wp-image-316" title="ddg_triangle_ratio_cotans" src="../cs177/wp-content/uploads/2011/11/ddg_triangle_ratio_cotans.svg" alt="" /></a></p>
<p><strong>Exercise 3.6:</strong> Let \(e\) be the edge vector along the base of a triangle. Show that the gradient of the hat function \(\phi\) on the opposite vertex is given by</p>
<p>\[ \nabla \phi = \frac{e^\perp}{2A}, \]</p>
<p>where \(e^\perp\) is the vector \(e\) rotated by a quarter turn in the counter-clockwise direction and \(A\) is the area of the triangle.</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_hatfunction_gradient.svg"><img class="aligncenter size-full wp-image-318" title="ddg_hatfunction_gradient" src="../cs177/wp-content/uploads/2011/11/ddg_hatfunction_gradient.svg" alt="" /></a></p>
<p><strong>Exercise 3.7:</strong> Show that for any hat function \(\phi\) associated with a given vertex</p>
<p>\[\langle \nabla \phi, \nabla \phi \rangle = \frac{1}{2}( \cot\alpha + \cot\beta )\]</p>
<p>within a given triangle, where \(\alpha\) and \(\beta\) are the interior angles at the remaining two vertices.</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_hatfunction_selfgradient_cotan.svg"><img class="aligncenter size-full wp-image-319" title="ddg_hatfunction_selfgradient_cotan" src="../cs177/wp-content/uploads/2011/11/ddg_hatfunction_selfgradient_cotan.svg" alt="" /></a></p>
<p><strong>Exercise 3.8:</strong> Show that for the hat functions \(\phi_i\) and \(\phi_j\) associated with vertices \(i\) and \(j\) (respectively) of the same triangle, we have</p>
<p>\[ \langle \nabla \phi_i, \nabla \phi_j \rangle = -\frac{1}{2} \cot \theta, \]</p>
<p>where \(\theta\) is the angle between the opposing edge vectors.</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_hatfunction_gradient_cotan.svg"><img class="aligncenter size-full wp-image-320" title="ddg_hatfunction_gradient_cotan" src="../cs177/wp-content/uploads/2011/11/ddg_hatfunction_gradient_cotan.svg" alt="" /></a></p>
<p>Putting all these facts together, we find that we can express the Laplacian of \(u\) at vertex \(i\) via the infamous <em>cotan formula</em></p>
<p>\[ (\Delta u)_i = \frac{1}{2} \sum_j (\cot \alpha_j + \cot \beta_j )( u_j - u_i ), \]</p>
<p>where we sum over the immediate neighbors of vertex \(i\).</p>
<p><strong><span style="text-decoration: underline;">Differential Forms</span></strong></p>
<p>The &#8220;Galerkin&#8221; approach taken above reflects a fairly standard way to discretize partial differential equations. But let&#8217;s try a different approach, based on exterior calculus. Again we want to solve the Poisson equation \(\Delta u = f\), which (if you remember our discussion of differential operators) can also be expressed as</p>
<p>\[ \star d \star d u = f. \]</p>
<p>We already outlined how to discretize this kind of expression in the notes on discrete exterior calculus, but let&#8217;s walk through it step by step. We start out with a 0-form \(u\), which is specified as a number \(u_i\) at each vertex:</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_cotan_laplace_0form.svg"><img class="aligncenter size-full wp-image-321" title="ddg_cotan_laplace_0form" src="../cs177/wp-content/uploads/2011/11/ddg_cotan_laplace_0form.svg" alt="" /></a></p>
<p>Next, we compute the discrete exterior derivative \(d u\), which just means that we want to <em>integrate</em> the derivative along each edge:</p>
<p>\[ (du)_{ij} = \int_{e_{ij}}\!du = \int_{\partial e_{ij}}\!u = u_j - u_i. \]</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_cotan_laplace_1form.svg"><img class="aligncenter size-full wp-image-346" title="ddg_cotan_laplace_1form" src="../cs177/wp-content/uploads/2011/11/ddg_cotan_laplace_1form.svg" alt="" /></a></p>
<p>(Note that the boundary \(\partial e_{ij}\) of the edge is simply its two endpoints \(v_i\) and \(v_j\).) The Hodge star converts a circulation along the edge \(e_{ij}\) into the flux through the corresponding dual edge \(e^\star_{ij}\). In particular, we take the <em>total circulation</em> along the primal edge, divide it by the edge length to get the <em>average pointwise circulation</em>, then multiply by the dual edge length to get the <em>total flux</em> through the dual edge:</p>
<p>\[ (\star du)_{ij} = \frac{|e^\star_{ij}|}{e_{ij}}(u_j - u_i). \]</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_cotan_laplace_dual1form1.svg"><img class="aligncenter size-full wp-image-323" title="ddg_cotan_laplace_dual1form" src="../cs177/wp-content/uploads/2011/11/ddg_cotan_laplace_dual1form1.svg" alt="" /></a></p>
<p>Here \(|e_{ij}|\) and \(e^\star_{ij}\) denote the length of the primal and dual edges, respectively. Next, we take the derivative of \(\star d u\) and integrate over the whole dual cell:</p>
<p>\[ (d \star d u)_i = \int_{C_i} d \star d u = \int_{\partial C_i} \star d u = \sum_j \frac{|e^\star_{ij}|}{|e_{ij}|}( u_j - u_i ). \]</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_cotan_laplace_dual2form.svg"><img class="aligncenter size-full wp-image-324" title="ddg_cotan_laplace_dual2form" src="../cs177/wp-content/uploads/2011/11/ddg_cotan_laplace_dual2form.svg" alt="" /></a></p>
<p>The final Hodge star simply divides this quantity by the area of \(C_i\) to get the average value over the cell, and we end up with a system of linear equations</p>
<p>\[ (\star d \star d u)_i = \frac{1}{|C_i|} \sum_j \frac{|e^\star_{ij}|}{|e_{ij}|}( u_j - u_i ) = f_i \]</p>
<p>where \(f_i\) is the value of the right-hand side at vertex \(i\). In practice, however, it&#8217;s often preferable to move the area factor \(|C_i|\) to the right hand side, since the resulting system</p>
<p>\[ (\star d \star d u)_i = \sum_j \frac{|e^\star_{ij}|}{|e_{ij}|}( u_j - u_i ) = |C_i| f_i \]</p>
<p>can be represented by a <em>symmetric</em> matrix. (Symmetric matrices are often easier to deal with numerically and lead to more efficient algorithms.) Another way of looking at this transformation is to imagine that we discretized the system</p>
<p>\[ d \star d u = \star f. \]</p>
<p>In other words, we converted an equation in terms of 0-forms into an equation in terms of \(n\)-forms. When working with surfaces, the operator \(d \star d\) is sometimes referred to as the <em>conformal Laplacian</em>, because it does not change when we subject our surface to a conformal transformation. Alternatively, we can think of \(d \star d\) as simply an operator that gives us the value of the Laplacian integrated over each dual cell of the mesh (instead of the pointwise value).</p>
<p><strong>Exercise 3.9:</strong> Consider a simplicial surface and suppose we place the vertices of the dual mesh at the circumcenters of the triangles (i.e., the center of the unique circle containing all three vertices):</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_hodge_cotan.svg"><img class="aligncenter size-full wp-image-325" title="ddg_hodge_cotan" src="../cs177/wp-content/uploads/2011/11/ddg_hodge_cotan.svg" alt="" /></a></p>
<p>Demonstrate that the dual edge \(e^\star\) (i.e., the line between the two circumcenters) bisects the primal edge orthogonally, and use this fact to show that</p>
<p>\[ \frac{|e^\star_{ij}|}{|e_{ij}|} = \frac{1}{2}(\cot \alpha_j + \cot \beta_j). \]</p>
<p>Hence the DEC discretization yields precisely the same &#8220;cotan-Laplace&#8221; operator as the Galerkin discretization.</p>
<p><strong><span style="text-decoration: underline;">Meshes and Matrices</span></strong></p>
<p>So far we&#8217;ve been giving a sort of &#8220;algorithmic&#8221; description of operators like Laplace. For instance, we determined that the Laplacian of a scalar function \(u\) at a vertex \(i\) can be approximated as</p>
<p>\[ (\Delta u)_i = \frac{1}{2} \sum_j (\cot\alpha_j+\cot\beta_j)(u_j - u_i), \]</p>
<p>where the sum is taken over the immediate neighbors \(j\) of \(i\). In code, this sum could easily be expressed as a <em>loop</em> and evaluated at any vertex. However, a key aspect of working with discrete differential operators is building their <em>matrix representation</em>. The motivation for encoding an operator as a matrix is so that we can solve systems like</p>
<p>\[ \Delta u = f \]</p>
<p>using a standard numerical linear algebra package. (To make matters even more complicated, some linear solvers are perfectly happy to work with algorithmic representations of operators called <em>callback functions</em> &#8212; in general, however, we&#8217;ll need a matrix.)</p>
<p>In the case of the Poisson equation, we want to construct a matrix \(L \in \mathbb{R}^{|V| \times |V|}\) (where \(|V|\) is the number of mesh vertices) such that for any vector \(u \in \mathbb{R}^{|V|}\) of values at vertices, the expression \(Lu\) effectively evaluates the formula above. But let&#8217;s start with something simpler &#8212; consider an operator \(B\) that computes the sum of all neighboring values:</p>
<p>\[ (Bu)_i = \sum_j u_j \]</p>
<p>How do we build the matrix representation of this operator? Think of \(B\) as a machine that takes a vector \(u\) of input values at each vertex and spits out another vector \(Bu\) of output values. In order for this story to make sense, we need to know which values correspond to which vertices. In other words, we need to assign a unique <em>index</em> to each vertex of our mesh, in the range \(1, \ldots, |V|\):</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_vertex_indices.svg"><img class="aligncenter size-full wp-image-326" title="ddg_vertex_indices" src="../cs177/wp-content/uploads/2011/11/ddg_vertex_indices.svg" alt="" /></a></p>
<p>It doesn&#8217;t matter which numbers we assign to which vertices, so long as there&#8217;s one number for every vertex and one vertex for every number. This mesh has twelve vertices and vertex 1 is next to vertices 2, 3, 4, 5, and 9. So we could compute the sum of the neighboring values as</p>
<p>\[ (Bu)_1 = \left[ \begin{array}{cccccccccccc} 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \end{array} \right]\left[ \begin{array}{c} u_1 \\ u_2 \\ u_3 \\ u_4 \\ u_5 \\ u_6 \\ u_7 \\ u_8 \\ u_9 \\ u_{10} \\ u_{11} \\ u_{12} \end{array} \right]. \]</p>
<p>Here we&#8217;ve put a &#8220;1&#8243; in the \(j\)th place whenever vertex \(j\) is a neighbor of vertex \(i\) and a &#8220;0&#8243; otherwise. Since this row gives the &#8220;output&#8221; value at the first vertex, we&#8217;ll make it the first row of the matrix \(B\). The entire matrix looks like this:</p>
<p>\[<br />
B =<br />
\left[<br />
\begin{array}{cccccccccccc}<br />
0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br />
1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\<br />
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\<br />
1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br />
1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br />
0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\<br />
0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\<br />
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\<br />
1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\<br />
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\<br />
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\<br />
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\<br />
\end{array}<br />
\right]<br />
\]</p>
<p>(You could verify that this matrix is correct, or you could go outside and play in the sunshine. Your choice.) In practice, fortunately, we don&#8217;t have to build matrices &#8220;by hand&#8221; &#8212; we can simply start with a matrix of zeros and fill in the nonzero entries by looping over local neighborhoods of our mesh.</p>
<p>Finally, one important thing to notice here is that many of the entries of \(B\) are <em>zero</em>. In fact, for most discrete operators the number of zeros far outnumbers the number of nonzeros. For this reason, it&#8217;s usually a good idea to use a <em>sparse matrix</em>, i.e., a data structure that stores only the location and value of nonzero entries (rather than explicitly storing every single entry of the matrix). The design of sparse matrix data structures is an interesting question all on its own, but conceptually you can imagine that a sparse matrix is simply a list of triples \((i,j,x)\) where \(i,j \in \mathbb{N}\) specify the row and column index of a nonzero entry and \(x \in \mathbb{R}\) gives its value.</p>
<p><strong><span style="text-decoration: underline;">Scalar Poisson Equation</span></strong></p>
<p>In the first part of the coding assignment you&#8217;ll build the cotan-Laplace operator and use it to solve the scalar Poisson equation</p>
<p>\[ \Delta \phi = \rho \]</p>
<p>on a triangle mesh, where \(\rho\) can be thought of as a (mass or charge) density and \(\phi\) can be thought of as a (gravitational or electric) potential. Once you&#8217;ve implemented the methods below, you can visualize the results via the <tt>libDDG</tt> GUI. (If you want to play with the density function \(\rho\), take a look at the method <tt>Viewer::updatePotential</tt>.)</p>
<p><strong>Coding 3.1:</strong> Implement the method <tt>Mesh::indexVertices()</tt> which assigns a unique ID to each vertex in the range \(0, \ldots, |V|-1\).</p>
<p><strong>Coding 3.2:</strong> Derive an expression for the cotangent of a given angle purely in terms of the two incident edge vectors and the standard Euclidean dot product \((\cdot)\) and cross product \((\times)\). Implement the method <tt>HalfEdge::cotan()</tt>, which computes the cotangent of the angle across from a given halfedge.</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_opposite_cotan.svg"><img class="aligncenter size-full wp-image-327" title="ddg_opposite_cotan" src="../cs177/wp-content/uploads/2011/11/ddg_opposite_cotan.svg" alt="" /></a></p>
<p><strong>Coding 3.3:</strong> Implement the methods <tt>Face::area()</tt> and <tt>Vertex::dualArea()</tt>. For the dual area of a vertex you can simply use one-third the area of the incident faces &#8212; you do not need to compute the area of the circumcentric dual cell. (This choice of area will not affect the order of convergence.)</p>
<p><strong>Coding 3.4:</strong> Using the methods you&#8217;ve written so far, implement the method <tt>Mesh::buildLaplacian()</tt> which builds a sparse matrix representing the cotan-Laplace operator. (Remember to initialize the matrix to the correct size!)</p>
<p><strong>Coding 3.5:</strong> Implement the method <tt>Mesh::solveScalarPoissonProblem()</tt> which solves the problem \(\Delta\phi = \rho\) where \(\rho\) is a scalar density on vertices (stored in <tt>Vertex::rho</tt>). You can use the method <tt>solve</tt> from <tt>SparseMatrix.h</tt>; \(\rho\) and \(\phi\) should be represented by instances of <tt>DenseMatrix</tt> of the appropriate size. Be careful about appropriately incorporating <em>dual areas</em> into your computations; also remember that the right-hand side cannot have a constant component!</p>
<p>You should verify that your code produces results that look something like these two images (density on the left; corresponding potential on the right):</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_bunny_potential.png"><img class="aligncenter size-full wp-image-328" title="ddg_bunny_potential" src="../cs177/wp-content/uploads/2011/11/ddg_bunny_potential.png" alt="" width="565" height="331" /></a></p>
<p>(Take a look at the new menu items in the GUI.)</p>
<p><strong><span style="text-decoration: underline;">Implicit Mean Curvature Flow</span></strong></p>
<p>Next, you&#8217;ll use nearly identical code to smooth out geometric detail on a surface mesh (also known as <em>fairing</em> or <em>curvature flow</em>). The basic idea is captured by the <em>heat equation</em>, which describes the way heat diffuses over a domain. For instance, if \(u\) is a scalar function describing the temperature at every point on the real line, then the heat equation is given by</p>
<p>\[ \frac{\partial u}{\partial t} = \frac{\partial^2 u}{\partial x^2}. \]</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_heat_equation.svg"><img class="aligncenter size-full wp-image-329" title="ddg_heat_equation" src="../cs177/wp-content/uploads/2011/11/ddg_heat_equation.svg" alt="" /></a></p>
<p>Geometrically this equation simply says that concave bumps get pushed down and convex bumps get pushed up &#8212; after a long time the heat distribution becomes completely flat. We also could have written this equation using the Laplacian: \(\frac{\partial u}{\partial t} = \Delta u\). In fact, this equation is exactly the one we&#8217;ll use to smooth out a surface, except that instead of considering the evolution of temperature, we consider the flow of the surface \(f: M \rightarrow \mathbb{R}^3\) itself:</p>
<p>\[ \frac{\partial f}{\partial t} = \Delta f. \]</p>
<p>Remember from <a title="Homework 2: Normals of Discrete Surfaces" href="index.html@p=285.html">our discussion of vertex normals</a> that \(\Delta f = 2HN,\) i.e., the Laplacian of position yields (twice) the mean curvature times the unit normal. Therefore, the equation above reads, &#8220;move the surface in the direction of the normal, with strength proportional to mean curvature.&#8221; In other words, it describes a <em>mean curvature flow</em>.</p>
<p>So how do we compute this flow? We already know how to discretize the term \(\Delta f\) &#8212; just use the cotangent discretization of Laplace. But what about the time derivative \(\frac{\partial f}{\partial t}\)? There are all sorts of interesting things to say about discretizing time, but for now let&#8217;s use a very simple idea: the change over time can be approximated by the <em>difference</em> of two consecutive states:</p>
<p>\[ \frac{\partial f}{\partial t} \approx \frac{f_h - f_0}{h}, \]</p>
<p>where \(f_0\) is the initial state of our system (here the initial configuration of our mesh) and \(f_h\) is the configuration after a mean curvature flow of some duration \(h &gt; 0\). Our discrete mean curvature flow then becomes</p>
<p>\[ \frac{f_h - f_0}{h} = \Delta f. \]</p>
<p>The only remaining question is: which values of \(f\) do we use on the right-hand side? One idea is to use \(f_0\), which results in the system</p>
<p>\[ f_h = f_0 + h\Delta f_0. \]</p>
<p>This scheme, called <em>forward Euler</em>, is attractive because it can be evaluated directly using the known data \(f_0\) &#8212; we don&#8217;t have to solve a linear system. Unfortunately, forward Euler is not numerically stable, which means we can take only very small time steps \(h\). One attractive alternative is to use \(f_h\) as the argument to \(\Delta\), leading to the system</p>
<p>\[ \underbrace{(I - h \Delta)}_A f_h = f_0, \]</p>
<p>where \(I\) is the identity matrix (try the derivation yourself!) This scheme, called <em>backward Euler</em>, is far more stable, though we now have to solve a linear system \(A f_h = f_0\). Fortunately this system is highly <em>sparse</em>, which means it&#8217;s not too expensive to solve in practice. (Note that this system is not much different from the Poisson system.)</p>
<p><strong>Coding 3.6:</strong> Implement the method <tt>Mesh::buildFlowOperator()</tt>, which should look very similar to <tt>Mesh::buildLaplacian</tt>.</p>
<p><strong>Coding 3.7:</strong> Implement the method <tt>Mesh::computeImplicitMeanCurvatureFlow()</tt>. Note that you can treat each of the components of \(f\) (\(x\), \(y\), and \(z\)) as separate scalar quantities.</p>
<p>You should verify that your code produces results that look something like these two images (original mesh on the left; smoothed mesh on the right):</p>
<p><a href="../cs177/wp-content/uploads/2011/11/ddg_smoothed_bunny.png"><img class="aligncenter size-full wp-image-330" title="ddg_smoothed_bunny" src="../cs177/wp-content/uploads/2011/11/ddg_smoothed_bunny.png" alt="" width="568" height="350" /></a></p>
<p><strong><span style="text-decoration: underline;">Skeleton Code and Handin</span></strong></p>
<p>Skeleton code for this assignment can be found here:</p>
<p><a href="http://brickisland.net/cs177/wp-content/uploads/2011/11/ddg_poisson.zip">ddg_poisson.zip</a></p>
<p>(You may want to use your Makefile from the last project!) You can easily locate all the methods that need to be implemented by searching for the string &#8220;TODO.&#8221; Please submit the <em>entire</em> project this time as a single zip file (i.e., not just the files you modify).</p>
                </div>
                <footer>
                                        November 13, 2012 |                                                                 Posted in: <a href="index.html@cat=3.html" title="View all posts in Homework" rel="category">Homework</a> |                                                             <a href="index.html@p=302.html#comments" class="comments-link"  title="Comment on Homework 3: The Discrete Laplacian">2 Comments &#187;</a>                </footer>
            </article>
                                <article class="post-285 post type-post status-publish format-standard hentry category-homework" id="post-285">
                <header class="opacity box">
                    <h2><a href="index.html@p=285.html" rel="bookmark" title="Permanent Link to Homework 2: Normals of Discrete Surfaces">Homework 2: Normals of Discrete Surfaces</a></h2>
                </header>
                <div class="entry">
                	<p><em>[Homework 2 has been released (below) and is due next Thursday by 5pm.  We suspect there will be a lot of questions about C++, <tt>libDDG</tt>, etc., so please do not hesitate to ask questions either in the comments (preferred) or via email.  Finally, some of the exercises require knowledge of exterior calculus that we haven't quite seen yet in class -- we will cover this material next time, but for those who want to get an early start I will post some additional notes that you can read through at your leisure.  Good luck!]</em></p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_discrete_normals.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_discrete_normals.svg" alt="" title="ddg_discrete_normals" class="aligncenter size-full wp-image-218" /></a></p>
<p>For a smooth surface in \(\mathbb{R}^3\), the <em>normal</em> direction is easy to define: it is the unique direction orthogonal to all tangent vectors &#8212; in other words, it&#8217;s the direction sticking &#8220;straight out&#8221; of the surface.  For discrete surfaces the story is not so simple.  If a mesh has <em>planar</em> faces (all vertices lie in a common plane) then of course the normal is well-defined: it is simply the normal of the plane.  But if the polygon is <em>nonplanar</em>, or if we ask for the normal at a <em>vertex</em>, then it is not as clear how the normal should be defined.</p>
<p>In practice there are a number of different possibilities, which arise from different ways of looking at the smooth geometry.  But before jumping in, let&#8217;s establish a few basic geometric facts.</p>
<p>&nbsp;</p>
<p><b><u>Area of a Polygon</u></b></p>
<p>Here&#8217;s a simple question: how do you compute the area of a polygon in the plane?  Suppose our polygon has vertices \(p_1, p_2, \ldots, p_n\).  One way to compute the area is to stick another point \(q\) in the middle and sum up the areas of triangles \(q,p_i,p_{i+1}\) as done on the left:</p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_polygon_area.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_polygon_area.svg" alt="" title="ddg_polygon_area" class="aligncenter size-full wp-image-219" /></a></p>
<p>A cute fact about life is that if we place \(q\) <em>anywhere</em> and sum up the <em>signed</em> triangle areas, we still recover the polygon area!  (Signed area just means <em>negative</em> if our vertices are oriented clockwise; <em>positive</em> if they&#8217;re counter-clockwise.)  You can get an idea of why this happens just by looking at the picture: positive triangles that cover &#8220;too much&#8221; area get accounted for by negative triangles.</p>
<p>The proof is an application of Stokes&#8217; theorem &#8212; consider a different expression for the area \(A\) of a planar polygon \(P\):</p>
<p>\[ A = \int_P dx \wedge dy. \]</p>
<p>Noting that \(dx \wedge dy = d(xdy) = -d(ydx)\), we can also express the area as</p>
<p>\[ A = \frac{1}{2} \int_P d(xdy) - d(ydx) = \frac{1}{2} \int_{\partial P} xdy - ydx, \]</p>
<p>where we&#8217;ve applied Stokes&#8217; theorem in the final step to convert our integral over the entire surface into an integral over just the boundary.  Now suppose that our polygon vertices have coordinates \(p_i = (x_i,y_i)\).  From here we can explicitly work out the boundary integral by summing up the integrals over each edge \(e_{ij}\):</p>
<p>\[ \int_{\partial P} xdy - ydx = \sum \int_{e_{ij}} xdy - ydx. \]</p>
<p>Since the coordinate functions \(x\) and \(y\) are <em>linear</em> along each edge (and their differentials \(dx\) and \(dy\) are therefore <em>constant</em>), we can write these integrals as</p>
<p>\[<br />
   \begin{array}{rcl}<br />
          \sum \int_{e_{ij}} xdy - ydx<br />
      &#038;=&#038; \sum \frac{x_i+x_j}{2}(y_j-y_i) - \frac{y_i+y_j}{2}(x_j-x_i) \\<br />
      &#038;=&#038; \frac{1}{2} \sum (p_i + p_j) \times (p_j - p_i) \\<br />
      &#038;=&#038; \frac{1}{2} \sum p_i \times p_j - p_i \times p_i - p_j \times p_j - p_j \times p_i \\<br />
      &#038;=&#038; \sum p_i \times p_j.<br />
   \end{array}<br />
\]</p>
<p>In short, we&#8217;ve shown that the area of a polygon can be written as simply</p>
<p>\[ A = \frac{1}{2} \sum_i p_i \times p_j. \]</p>
<p><b>Exercise 2.1</b> Complete the proof by showing that for any point \(q\) the signed areas of triangles \((q,p_i,p_{i+1})\) sum to precisely the expression above.</p>
<p>&nbsp;</p>
<p><b><u>Vector Area</u></b></p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_vector_area.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_vector_area.svg" alt="" title="ddg_vector_area" class="aligncenter size-full wp-image-220" /></a></p>
<p>A more general version of the situation we just looked at with polygon areas is the <em>vector area</em> of a surface patch \(f: M \rightarrow \mathbb{R}^3\), which is defined as the integral of the surface normal over the entire domain:</p>
<p>\[ N_\mathcal{V} := \int_M N dA. \]</p>
<p>A very nice property of the vector area is that it depends only on the shape of the boundary \(\partial M\) (as you will demonstrate in the next exercise).  As a result, two surfaces that look very different (such as the ones above) can still have the same vector area &#8212; the physical intuition here is that the vector area measures the total <em>flux</em> through the boundary curve.</p>
<p>For a <em>flat</em> region the normal is constant over the surface and we get just the usual area times the unit normal vector.  Things get more interesting when the surface is not flat &#8212; for instance, the vector area of a circular band is <em>zero</em> since opposing normals cancel each-other out:</p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_circular_band.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_circular_band.svg" alt="" title="ddg_circular_band" class="aligncenter size-full wp-image-221" /></a></p>
<p><b>Exercise 2.2</b> Using Stokes&#8217; theorem, show that the vector area can be written as</p>
<p>\[ N_\mathcal{V} = \frac{1}{2} \int_{\partial M} f \wedge df, \]</p>
<p>where the product of two vectors in \(\mathbb{R}^3\) is given by the usual cross product \(\times\).</p>
<p>&nbsp;</p>
<p><b><u>Gradient of Triangle Area</u></b></p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_triangle_area_gradient.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_triangle_area_gradient.svg" alt="" title="ddg_triangle_area_gradient" class="aligncenter size-full wp-image-222" /></a></p>
<p>Here&#8217;s another fairly basic question: consider a triangle sitting in \(\mathbb{R}^3\), and imagine that we&#8217;re allowed to pull on one of its vertices \(p\).  What&#8217;s the quickest way to increase its area \(A\)?  In other words, what&#8217;s the <em>gradient</em> of \(A\) with respect to \(p\)?</p>
<p>&nbsp;</p>
<p><b>Exercise 2.3</b> Show that the area gradient is given by</p>
<p>\[ \nabla_p A_\sigma = \frac{1}{2} \mathbf{u}^{\perp} \]</p>
<p>where \(\mathbf{u^\perp}\) is the edge vector across from \(p\) rotated by an angle \(\pi/2\) in the plane of the triangle (such that it points toward \(p\)).  You should require only a few <em>very simple</em> geometric arguments &#8212; there&#8217;s no need to write things out in coordinates, etc.</p>
<p><b><u>Vertex Normals from Area Gradient</u></b></p>
<p>Ok, with these facts out of the way let&#8217;s take a look at some different ways to define vertex normals.  There are essentially only two definitions that arise naturally from the smooth picture: the <em>area gradient</em> and the <em>volume gradient</em>; we&#8217;ll start with the former.</p>
<p>The area gradient asks, &#8220;which direction should we `push&#8217; the surface in order to increase its total area \(A\) as quickly as possible?&#8221;  Sliding all points tangentially along the surface clearly doesn&#8217;t change anything: we just end up with the same surface.  In fact, the only thing we can do to increase surface area is move the surface in the <em>normal</em> direction.  The idea, then, is to <em>define</em> the vertex normal as the gradient of area with respect to a given vertex.</p>
<p>Since we already know how to express the area gradient for a single triangle \(\sigma\), we can easily express the area gradient for the entire surface:</p>
<p>\[ \nabla_p A = \sum_\sigma \nabla A_\sigma. \]</p>
<p>Of course, a given vertex \(p\) influences only the areas of the triangles touching \(p\).  So we can just sum up the area gradients over this small collection of triangles.</p>
<p>&nbsp;</p>
<p><b>Exercise 2.4</b> Show that the gradient of surface area with respect to vertex \(p_i\) can be expressed as</p>
<p>\[ \nabla_p A = \frac{1}{2}\sum_j (\cot\alpha_j + \cot\beta_j)( p_j - p_i ) \]</p>
<p>where \(p_j\) is the coordinate of the \(j\)th neighbor of \(p_i\) and \(\alpha_j\) and \(\beta_j\) are the angles across from edge \((p_i,p_j)\).</p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_cotan_formula.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_cotan_formula.svg" alt="" title="ddg_cotan_formula" class="aligncenter size-full wp-image-223" /></a></p>
<p>&nbsp;</p>
<p><b><u>Mean Curvature Vector</u></b></p>
<p>The expression for the area gradient derived in the last exercise shows up all over discrete differential geometry, and is often referred to as the <em>cotan formula</em>.  Interestingly enough this same expression appears when taking a completely different approach to defining vertex normals, by way of the <em>mean curvature vector</em> \(HN\).  In particular, for a smooth surface \(f: M \rightarrow \mathbb{R}^3\) we have</p>
<p>\[ \Delta f = 2HN \]</p>
<p>where \(H\) is the mean curvature, \(N\) is the unit surface normal (which we&#8217;d like to compute), and \(\Delta\) is the Laplace-Beltrami operator (see below).  Therefore, another way to define vertex normals for a discrete surface is to simply apply a discrete Laplace operator to the vertex positions and normalize the resulting vector.</p>
<p>The question now becomes, &#8220;how do you discretize the Laplacian?&#8221;  We&#8217;ll take a closer look at this question in the future, but the remarkable fact is that the most straightforward discretization of \(\Delta\) leads us right back to the cotan formula!  In other words, the vertex normals we get from the mean curvature vector are precisely the same as the ones we get from the area gradient.</p>
<p>This whole story also helps us get better intuition for the Laplace-Beltrami operator \(\Delta\) itself.  Unfortunately, there&#8217;s no really nice way to write \(\Delta\) &#8212; the standard coordinate formula you&#8217;ll find in a textbook on differential geometry is \(\Delta \phi = \frac{1}{\sqrt{|g|}} \frac{\partial}{\partial x^i}(\sqrt{|g|} g^{ij} \frac{\partial}{\partial x^j}\phi)\), where \(g\) is the metric.  However, this obfuscated expression provides little intuition about what \(\Delta\) really does, and is damn-near useless when it comes to discretization since for a triangle mesh we <em>never</em> have a coordinate representation of \(g\)!  Later, using exterior calculus, we&#8217;ll see that the (0-form) Laplacian can be expressed as \(\Delta = \star d \star d\), which leads to a fairly straightforward discretization.  But for now, we&#8217;ll make use of a nice tool we learned about earlier: <em>conformal parameterization</em>.  Remember that if \(f\) is a conformal map, then lengths on \(M\) and lengths on \(f(M)\) are related by a positive scaling \(e^{u}\).  In other words, \(|df(X)| = e^{u}|X|\) for some real-valued function \(u\) on \(M\).  Moreover, a conformal parameterization always exists &#8212; in other words, we don&#8217;t have to make any special assumptions about our geometry in order to use conformal coordinates in proofs or other calculations.  The reason conformal coordinates are useful when talking about Laplace-Beltrami is that we can write \(\Delta\) as simply a rescaling of the standard Laplacian in the plane, i.e., as the sum of second partial derivatives divided by the metric scaling factor \(e^{2u}\):</p>
<p>\[ \Delta \phi = \frac{d(d\phi(X))(X) + d(d\phi(Y))(Y)}{e^{2u}}, \]</p>
<p>where \(X\) and \(Y\) are any pair of unit, orthogonal directions.</p>
<p>What&#8217;s the geometric meaning here?  Remember that for a good old-fashioned function \(\phi: \mathbb{R} \rightarrow \mathbb{R}\) in 1D, second derivatives basically tell us about the <em>curvature</em> of a function, e.g., is it concave or convex?</p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_1d_curvature.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_1d_curvature.svg" alt="" title="ddg_1d_curvature" class="aligncenter size-full wp-image-224" /></a></p>
<p>Well, since \(\Delta\) is a <em>sum</em> of second derivatives, it&#8217;s no surprise that it tells us something about the <em>mean</em> curvature!</p>
<p>&nbsp;</p>
<p><b>Exercise 2.5</b> Show that the relationship \(\Delta f = 2HN\) holds.</p>
<p>&nbsp;</p>
<p><b><u>Vertex Normals from Volume Gradient</u></b></p>
<p>An alternative way to come up with normals is to look at the <em>volume gradient</em>.  Suppose that our surface encloses some region of space with total volume \(\mathcal{V}\).  As before, we know that sliding the surface along itself tangentially doesn&#8217;t really change anything: we end up with the same surface, which encloses the same region of space.  Therefore, the quickest way to increase \(\mathcal{V}\) is to again move the surface in the normal direction.  A somewhat surprising fact is that, in the discrete case, the volume gradient actually yields a <em>different</em> definition for vertex normals than the one we got from the area gradient.  To express this gradient, we&#8217;ll use three-dimensional versions of of our &#8220;basic facts&#8221; from above.</p>
<p>First, much like we broke the area of a polygon into triangles, we&#8217;re going to decompose the volume enclosed by our surface into a collection of tetrahedra.  Each tetrahedron includes exactly one face of our discrete surface, along with a new point \(q\).  For instance, here&#8217;s what the volume might look like in the vicinity of a vertex \(p\):</p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_volume_tetrahedralization.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_volume_tetrahedralization.svg" alt="" title="ddg_volume_tetrahedralization" class="aligncenter size-full wp-image-225" /></a></p>
<p>Just as in the polygon case the location of \(q\) makes no difference, as long as we work with the <em>signed</em> volume of the tetrahedra.  (Can you prove it?)</p>
<p>Next, what&#8217;s the volume gradient for a single tetrahedron?  One way to write the volume of a tet is as</p>
<p>\[ \mathcal{V} = \frac{1}{3} A h, \]</p>
<p>where \(A\) is the area of the base triangle and \(h\) is the height.  Then using the same kind of geometric reasoning as in the triangle case, we know that</p>
<p>\[ \nabla_p \mathcal{V} = \frac{1}{3} A N, \]</p>
<p>where \(N\) is the unit normal to the base.</p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_tetrahedron_volume_gradient.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_tetrahedron_volume_gradient.svg" alt="" title="ddg_tetrahedron_volume_gradient" class="aligncenter size-full wp-image-226" /></a></p>
<p>To express the gradient of the enclosed volume with respect to a given vertex \(p\), we simply sum up the gradients for the tetrahedra containing \(p\):</p>
<p>\[ \nabla_p \mathcal{V} = \sum_i \mathcal{V}_i = \frac{1}{3} \sum_i A_i N_i. \]</p>
<p>At first glance this sum does not lead to a nice expression for \(\Delta_p \mathcal{V}\) &#8212; for instance, it uses the normals \(N_i\) of faces that have little to do with our surface geometry.  However, remember that we can place \(q\) anywhere we please and still get the same expression for volume.  In particular, if we put \(q\) directly on top of \(p\), then the \(N_i\) and \(A_i\) coincide with the normals and areas (respectively) of the faces containing \(p\) from our original surface:</p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_volume_gradient_proof.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_volume_gradient_proof.svg" alt="" title="ddg_volume_gradient_proof" class="aligncenter size-full wp-image-227" /></a></p>
<p><b>Exercise 2.6</b> Show that the volume gradient points in the same direction as the vector area \(N_\mathcal{V}\) (i.e., show that they are the same up to a constant factor).</p>
<p>&nbsp;</p>
<p><b><u>Other Definitions</u></b></p>
<p>So far we&#8217;ve only looked at definitions for vertex normals that arise from some smooth definition.  This way of thinking captures the essential spirit of discrete differential geometry: relationships from the smooth setting should persist unperturbed in the discrete setting (e.g., \(\Delta f = 2HN\) should be true independent of whether \(\Delta\), \(H\), and \(N\) are smooth objects or discrete ones).  Nonetheless, there are a number of common definitions for vertex normals that do not have a known origin in the smooth world.  (Perhaps you can find one?)</p>
<p>&nbsp;</p>
<p><b><u>Uniform Weighting</u></b></p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_uniform_vertex_normals.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_uniform_vertex_normals.svg" alt="" title="ddg_uniform_vertex_normals" class="aligncenter size-full wp-image-228" /></a></p>
<p>Perhaps the simplest way to get vertex normals is to just add up the neighboring face normals:</p>
<p>\[ N_U := \sum_i N_i \]</p>
<p>The main drawback to this approach is that two different tessellations of the same geometry can produce very different vertex normals, as illustrated above.</p>
<p><b><u>Tip-Angle Weights</u></b></p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_vertex_normals.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_vertex_normals.svg" alt="" title="ddg_vertex_normals" class="aligncenter size-full wp-image-229" /></a></p>
<p>A simple way to reduce dependence on the tessellation is to weigh face normals by their corresponding <em>tip angles</em> \(\theta\), i.e., the interior angles incident on the vertex of interest:</p>
<p>\[ N_\theta := \sum_i \theta_i N_i \]</p>
<p>&nbsp;</p>
<p><b><u>Sphere-Inscribed Polytope</u></b></p>
<p><a href="../cs177/wp-content/uploads/2011/10/ddg_spherical_polytope.svg"><img src="../cs177/wp-content/uploads/2011/10/ddg_spherical_polytope.svg" alt="" title="ddg_spherical_polytope" class="aligncenter size-full wp-image-230" /></a></p>
<p>Here&#8217;s another interesting approach to vertex normals: consider the sphere \(S^2\) consisting of all points unit distance from the origin in \(\mathbb{R}^3\).  A nice fact about the sphere is that the unit normal \(N\) at a point \(x \in S^2\) is simply the point itself!  I.e., \(N(x) = x\).  So if we start out with a polytope whose vertices all sit on the sphere, one reasonable way to define vertex normals is to simply use the vertex positions.</p>
<p>In fact, it&#8217;s not too hard to show that the direction of the normal at a vertex \(p_i\) can be expressed purely in terms of the edge vectors \(e_j = p_j &#8211; p_i\), where \(p_j\) are the immediate neighbors of \(p_i\).  In particular, we have</p>
<p>\[ N_S = \frac{1}{c} \sum_{j=0}^{n-1} \frac{e_j \times e_{j+1}}{|e_j|^2 |e_{j+1}|^2} \]</p>
<p>where the constant \(c \in \mathbb{R}\) can be ignored since we&#8217;re only interested in the <em>direction</em> of the normal.  (For a detailed derivation of this expression, see Max, <em>&#8220;Weights for Computing Vertex Normals from Facet Normals.&#8221;</em>)  Of course, since this expression depends only on the edge vectors it can be evaluated on any mesh (not just those inscribed in a sphere).</p>
<p>&nbsp;</p>
<p><b><u>Coding Assignment</u></b></p>
<p>Implement the following methods in <tt>libDDG</tt>:</p>
<ul>
<li> <tt>Vertex::normalEquallyWeighted()</tt> <br />
<b>Purpose:</b> returns unit vertex normal using uniform weights \(N_U\)</li>
<li> <tt>Vertex::normalAreaWeighted()</tt> <br />
<b>Purpose:</b> returns unit vertex normal using face area weights \(N_\mathcal{V}\)</li>
<li> <tt>Vertex::normalAngleWeighted()</tt> <br />
<b>Purpose:</b> returns unit vertex normal using tip angle weights \(N_\theta\)</li>
<li> <tt>Vertex::normalMeanCurvature()</tt> <br />
<b>Purpose:</b> returns unit mean curvature normal \(\Delta f\)</li>
<li> <tt>Vertex::normalSphereInscribed()</tt> <br />
<b>Purpose:</b> returns unit sphere-inscribed normal \(N_S\)</li>
</ul>
<p>(The definitions for these methods can be found in <tt>libddg/src/Vertex.cpp</tt>.)</p>
<p>Once you&#8217;ve successfully implemented these methods, test them out on the provided meshes.  For convenience you can flip through the different methods using the keys <tt>[1]</tt>-<tt>[5]</tt>.  You can also see what the mesh looks like by viewing it in &#8220;wireframe&#8221; mode.  Do you notice that some definitions work better than others?  When?  Why?  The only thing you need to submit for the coding assignment (via email) is your modified version of <tt>Vertex.cpp</tt>.  (Of course, if you modify other files you should submit these too!  For instance, you might find it convenient to add a method <tt>HalfEdge::cotan()</tt> that computes the cotangent of the angle across from a given half edge.)</p>
<p>&nbsp;</p>
<p>Example meshes can be found here: <a href='http://brickisland.net/cs177/wp-content/uploads/2011/10/ddg_hw2_meshes.zip'>ddg_hw2_meshes.zip</a></p>
                </div>
                <footer>
                                        October 30, 2012 |                                                                 Posted in: <a href="index.html@cat=3.html" title="View all posts in Homework" rel="category">Homework</a> |                                                             <a href="index.html@p=285.html#comments" class="comments-link"  title="Comment on Homework 2: Normals of Discrete Surfaces">1 Comment &#187;</a>                </footer>
            </article>
                                <article class="post-281 post type-post status-publish format-standard hentry category-homework" id="post-281">
                <header class="opacity box">
                    <h2><a href="index.html@p=281.html" rel="bookmark" title="Permanent Link to Code for Next Assignment Posted">Code for Next Assignment Posted</a></h2>
                </header>
                <div class="entry">
                	<p>Code for the next assignment can be downloaded here:</p>
<p><a href='http://brickisland.net/cs177/wp-content/uploads/2011/10/ddg_normals.zip'>ddg_normals.zip</a></p>
<p>We&#8217;ll provide more details about the actual assignment later this week (including the due date), but for now just try to see if you can get the code to compile.  Instructions on getting started can be found in the <a href="http://brickisland.net/libddg/doc/libddg_userguide.pdf">user guide</a> &#8212; this precise sequence of steps may not work for you, but it should at least get you started.  If you&#8217;re having trouble (or finding wild success!), feel free to gripe about it in the comments (below).</p>
<p>If you&#8217;ve never seen C++ before, don&#8217;t freak out &#8212; the path is pretty clearly laid out for you in the assignment.</p>
<p>Finally, we will be arranging a session (probably some evening later this week &#8212; with food!) to help setup the code and get everything compiling/linking.  <strong><em>Please leave a comment below indicating which evenings/times work for you.</em></strong></p>
                </div>
                <footer>
                                        October 24, 2012 |                                                                 Posted in: <a href="index.html@cat=3.html" title="View all posts in Homework" rel="category">Homework</a> |                                                             <a href="index.html@p=281.html#comments" class="comments-link"  title="Comment on Code for Next Assignment Posted">10 Comments &#187;</a>                </footer>
            </article>
                                    <nav class="navigation">
            <div class="alignleft"><a href="index.html@cat=3&amp;paged=2.html" ><span>&laquo;</span> Older Entries</a></div>
        <div class="alignright"></div>
    </nav>        </div>
    <aside id="sidebar">
	<ul>
	    <li id="search-3" class="widget widget_search"><form role="search" method="get" id="searchform" action="index.html" >
	<div><label class="screen-reader-text" for="s">Search for:</label>
	<input type="text" value="" name="s" id="s" />
	<input type="submit" id="searchsubmit" value="Search" />
	</div>
	</form></li><li id="meta-3" class="widget widget_meta"><h3 class="widgettitle">Meta</h3>			<ul>
						<li><a href="wp-login.php.html">Log in</a></li>
			<li><a href="index.html@feed=rss2" title="Syndicate this site using RSS 2.0">Entries <abbr title="Really Simple Syndication">RSS</abbr></a></li>
			<li><a href="index.html@feed=comments-rss2" title="The latest comments to all posts in RSS">Comments <abbr title="Really Simple Syndication">RSS</abbr></a></li>
			<li><a href="http://wordpress.org/" title="Powered by WordPress, state-of-the-art semantic personal publishing platform.">WordPress.org</a></li>
						</ul>
</li><li id="pages-2" class="widget widget_pages"><h3 class="widgettitle">Pages</h3>		<ul>
			<li class="page_item page-item-4"><a href="index.html@page_id=4.html">Course Information</a></li>
<li class="page_item page-item-11"><a href="index.html@page_id=11.html">Homework Assignments</a></li>
<li class="page_item page-item-9"><a href="index.html@page_id=9.html">Lecture Slides</a></li>
<li class="page_item page-item-13"><a href="index.html@page_id=13.html">Subscriptions</a></li>
		</ul>
		</li><li id="categories-3" class="widget widget_categories"><h3 class="widgettitle">Categories</h3>		<ul>
	<li class="cat-item cat-item-4"><a href="index.html@cat=4.html" title="View all posts filed under Administration">Administration</a> (2)
</li>
	<li class="cat-item cat-item-3 current-cat"><a href="index.html@cat=3.html" title="View all posts filed under Homework">Homework</a> (6)
</li>
	<li class="cat-item cat-item-5"><a href="index.html@cat=5.html" title="View all posts filed under Notes">Notes</a> (12)
</li>
		</ul>
</li><li id="categoryposts-3" class="widget widget_categoryposts"><h3 class="widgettitle">Course Notes</h3><ul>
		<li class="cat-post-item">
			<a class="post-title" href="index.html@p=104.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to the Geometry of Surfaces">A Quick and Dirty Introduction to the Geometry of Surfaces</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=139.html" rel="bookmark" title="Permanent link to Derivatives and Tangent Vectors">Derivatives and Tangent Vectors</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=162.html" rel="bookmark" title="Permanent link to The Fundamental Polygon">The Fundamental Polygon</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=187.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to the Geometry of Curves">A Quick and Dirty Introduction to the Geometry of Curves</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=214.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to the Curvature of Surfaces">A Quick and Dirty Introduction to the Curvature of Surfaces</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=235.html" rel="bookmark" title="Permanent link to Geometry in Coordinates">Geometry in Coordinates</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=262.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part I: Vectors and 1-Forms">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part I: Vectors and 1-Forms</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=272.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part II: Differential Forms and the Wedge Product">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part II: Differential Forms and the Wedge Product</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=294.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part III: Hodge Duality">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part III: Hodge Duality</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=296.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part IV: Differential Operators">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part IV: Differential Operators</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=298.html" rel="bookmark" title="Permanent link to A Quick and Dirty Introduction to Exterior Calculus &#8212; Part V: Integration and Stokes&#8217; Theorem">A Quick and Dirty Introduction to Exterior Calculus &#8212; Part V: Integration and Stokes&#8217; Theorem</a>
			
			
						
						
					</li>
			<li class="cat-post-item">
			<a class="post-title" href="index.html@p=307.html" rel="bookmark" title="Permanent link to Discrete Exterior Calculus">Discrete Exterior Calculus</a>
			
			
						
						
					</li>
	</ul>
</li>	</ul>
</aside></div><!-- id='content' -->
    </div><!-- id='wrapcontent' -->
    <div id="wrapfooter" class="wrapper">
    	<footer id="footer">
    		        	<p class="clear copy">
            	<a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-nd/3.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Introduction to Discrete Differential Geometry</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License</a>.        	</p>
    	</footer>
	</div>
</div>
</body>
</html>